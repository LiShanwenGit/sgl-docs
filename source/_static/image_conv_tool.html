<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å›¾ç‰‡å–æ¨¡å·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            padding: 30px;
            text-align: center;
            color: white;
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* æ ‡ç­¾é¡µæ ·å¼ */
        .tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 2px solid #e0e0e0;
        }

        .tab-button {
            padding: 15px 30px;
            border: none;
            background: transparent;
            font-size: 1.1em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #666;
            border-bottom: 3px solid transparent;
        }

        .tab-button:hover {
            background: rgba(79, 172, 254, 0.1);
            color: #4facfe;
        }

        .tab-button.active {
            background: white;
            color: #4facfe;
            border-bottom-color: #4facfe;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .main-content {
            display: flex;
            gap: 30px;
            padding: 30px;
            flex-wrap: wrap;
        }

        .left-panel {
            flex: 1;
            min-width: 350px;
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .right-panel {
            flex: 1;
            min-width: 350px;
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            transition: transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), box-shadow 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .section:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
        }

        .section h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.3em;
            font-weight: 600;
        }

        .file-input-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 50px;
            border: 2px dashed #ccc;
            border-radius: 8px;
            background: #fff;
            transition: all 0.3s ease;
        }

        .file-input-container:hover {
            border-color: #4facfe;
            background: #f0f8ff;
        }

        .file-input {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        .file-input-label {
            text-align: center;
            padding: 5px;
            color: #666;
            cursor: pointer;
            font-size: 0.9em;
        }

        .file-input-label i {
            font-size: 1.2em;
            display: inline-block;
            margin-right: 8px;
            color: #999;
            vertical-align: middle;
        }

        .file-input-label div {
            display: inline-block;
            vertical-align: middle;
        }

        .preview-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 200px;
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        /* æ£‹ç›˜æ ¼èƒŒæ™¯æ ·å¼ */
        .chessboard-bg {
            background-image:
                linear-gradient(45deg, #ccc 25%, transparent 25%),
                linear-gradient(-45deg, #ccc 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #ccc 75%),
                linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #f0f0f0;
        }

        #previewImage {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .size-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .size-input-group {
            flex: 1;
            min-width: 120px;
        }

        .size-input-group label {
            display: block;
            margin-bottom: 5px;
            color: #666;
            font-size: 0.9em;
        }

        .size-input-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s ease;
        }

        .size-input-group input:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }

        .aspect-lock {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
        }

        .aspect-lock input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .aspect-lock label {
            color: #666;
            font-size: 0.9em;
            cursor: pointer;
        }

        .select-group {
            margin-bottom: 20px;
        }

        .select-group label {
            display: block;
            margin-bottom: 8px;
            color: #666;
            font-weight: 500;
        }

        .select-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            background: white;
            cursor: pointer;
            transition: border-color 0.3s ease;
        }

        .select-group select:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }

        .filename-input-group {
            margin-bottom: 20px;
        }

        .filename-input-group label {
            display: block;
            margin-bottom: 8px;
            color: #666;
            font-weight: 500;
        }

        .filename-input-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s ease;
        }

        .filename-input-group input:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }

        .convert-btn {
            width: 100%;
            padding: 18px;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1.2em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
        }

        .convert-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(79, 172, 254, 0.6);
        }

        .convert-btn:active {
            transform: translateY(0);
        }

        .convert-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* å¤šå¡ç‰‡å¸ƒå±€æ ·å¼ */
        .header-section {
            margin-bottom: 20px;
        }

        .add-card-btn {
            padding: 10px 15px;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .add-card-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
        }

        #cardsContainer {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .image-card {
            position: relative;
        }

        .delete-card-btn {
            background: none;
            border: none;
            font-size: 1.2em;
            cursor: pointer;
            color: #999;
            transition: color 0.3s ease;
            padding: 5px;
            border-radius: 50%;
        }

        .delete-card-btn:hover {
            color: #ff4757;
            background: #ffebee;
        }

        .delete-card-btn:disabled {
            color: #e0e0e0;
            cursor: not-allowed;
        }

        .image-card h3 {
            color: #333;
            margin: 0;
            font-size: 1.1em;
        }

        .card-status {
            margin-top: 10px;
            font-size: 0.8em;
            color: #999;
            text-align: right;
        }

        /* è¿›åº¦æ¡æ ·å¼ */
        .progress-container {
            margin-bottom: 20px;
        }

        .progress-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9em;
            color: #666;
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background-color: #e0e0e0;
            border-radius: 6px;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            border-radius: 6px;
            transition: width 0.3s ease;
            box-shadow: 0 2px 4px rgba(79, 172, 254, 0.3);
        }



        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }

            .size-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .aspect-lock {
                margin-left: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¨ å›¾ç‰‡å–æ¨¡å·¥å…·</h1>
        </div>

        <!-- æ ‡ç­¾é¡µ -->
        <div class="tabs">
            <button class="tab-button active" data-tab="image-molding">å›¾ç‰‡å–æ¨¡</button>
        </div>

        <!-- å›¾ç‰‡å–æ¨¡æ ‡ç­¾å†…å®¹ -->
        <div class="tab-content active" id="image-molding">
            <div class="main-content">
            <!-- å·¦ä¾§é¢æ¿ï¼šå›¾ç‰‡å¤„ç†å¡ç‰‡ -->
            <div class="left-panel">
                <div class="section header-section">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <h2>å›¾ç‰‡å¤„ç† <span id="cardCount" style="color: #4facfe; font-weight: normal; font-size: 0.8em;">(1ä¸ªå›¾ç‰‡é€‰é¡¹å¡)</span></h2>
                        <button id="addCardBtn" class="add-card-btn">+ å¢åŠ å›¾ç‰‡é€‰é¡¹å¡</button>
                    </div>
                </div>

                <!-- å›¾ç‰‡å¤„ç†å¡ç‰‡å®¹å™¨ -->
                <div id="cardsContainer">
                    <!-- å¡ç‰‡æ¨¡æ¿ -->
                    <div class="image-card section" data-card-index="0">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3>å›¾ç‰‡ 1</h3>
                            <button class="delete-card-btn" title="åˆ é™¤å›¾ç‰‡">ğŸ—‘ï¸</button>
                        </div>

                        <!-- å›¾ç‰‡é€‰æ‹© -->
                        <div class="file-input-container">
                            <input type="file" class="image-file-input file-input" accept="image/jpg,image/jpeg,image/png,image/bmp" multiple>
                            <label class="file-input-label">
                                <i>ğŸ“</i>
                                <div>ç‚¹å‡»æˆ–æ‹–æ‹½å›¾ç‰‡åˆ°æ­¤å¤„</div>
                                <div style="font-size: 0.8em; color: #999; margin-top: 5px;">æ”¯æŒæ ¼å¼ï¼šJPGã€JPEGã€PNGã€BMP</div>
                                <div style="font-size: 0.8em; color: #999; margin-top: 5px;">å·²æ·»åŠ  <span class="image-count">0</span>/1024 å¼ å›¾ç‰‡</div>
                            </label>
                        </div>

                        <!-- åŸå›¾é¢„è§ˆ -->
                        <div style="margin-top: 15px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                <h4 style="color: #666; margin: 0;">åŸå›¾é¢„è§ˆ</h4>
                                <div style="display: flex; gap: 5px;">
                                    <button class="center-canvas-btn" style="background: rgba(79, 172, 254, 0.8); color: white; border: none; border-radius: 4px; padding: 2px 8px; font-size: 10px; cursor: pointer; transition: all 0.3s ease;">å±…ä¸­ç”»å¸ƒ</button>
                                    <button class="delete-all-btn" style="background: rgba(220, 53, 69, 0.8); color: white; border: none; border-radius: 4px; padding: 2px 8px; font-size: 10px; cursor: pointer; transition: all 0.3s ease;">åˆ é™¤æ‰€æœ‰</button>
                                </div>
                            </div>
                            <div style="position: relative; border-radius: 8px; overflow: hidden; height: 150px;" class="chessboard-bg">
                                <div class="preview-canvas-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden;">
                                    <div class="preview-images" style="position: absolute; top: 0; left: 0; display: grid; grid-template-columns: repeat(9, auto); gap: 8px; padding: 10px; transform-origin: center; transition: transform 0.1s ease;"></div>
                                </div>
                            </div>
                        </div>
                        <!-- è¾“å‡ºé¢„è§ˆ -->
                        <div style="margin-top: 15px;">
                            <h4 style="margin-bottom: 5px; color: #666;">è¾“å‡ºé¢„è§ˆ</h4>
                            <div style="position: relative; border-radius: 8px; overflow: hidden; height: 150px;" class="chessboard-bg">
                                <div class="preview-canvas-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden;">
                                    <div class="output-preview-images" style="position: absolute; top: 0; left: 0; display: grid; grid-template-columns: repeat(9, auto); gap: 8px; padding: 10px; transform-origin: center; transition: transform 0.1s ease;"></div>
                                </div>
                            </div>
                        </div>

                        <!-- å°ºå¯¸è°ƒæ•´ -->
                        <div style="margin-top: 15px;">
                            <h4 style="margin-bottom: 10px; color: #666;">å°ºå¯¸è°ƒæ•´</h4>
                            <div class="size-controls">
                                <div class="size-input-group">
                                    <label>å®½åº¦ (px)</label>
                                    <input type="number" class="width-input" min="1" step="1" disabled>
                                </div>
                                <div class="size-input-group">
                                    <label>é«˜åº¦ (px)</label>
                                    <input type="number" class="height-input" min="1" step="1" disabled>
                                </div>
                                <div class="aspect-lock" style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" class="lock-aspect" checked style="width: 18px; height: 18px; margin: 0; cursor: pointer;">
                    <span>é”å®šæ¯”ä¾‹</span>
                </div>
                            </div>
                        </div>

                        <!-- æ•°ç»„åå‰ç¼€ -->
                        <div style="margin-top: 15px;">
                            <h4 style="margin-bottom: 10px; color: #666;">æ•°ç»„åå‰ç¼€</h4>
                            <div class="filename-input-group">
                                <input type="text" class="array-prefix-input" placeholder="è¯·è¾“å…¥æ•°ç»„åå‰ç¼€">
                            </div>
                        </div>

                        <!-- è¾“å‡ºè¯¦æƒ… -->
                        <div style="margin-top: 15px;">
                            <h4 style="margin-bottom: 10px; color: #666;">è¾“å‡ºè¯¦æƒ…</h4>
                            <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; font-size: 0.9em;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                    <span style="color: #666;">åŸå›¾æ•°æ®å¤§å°ï¼š</span>
                                    <span class="original-size" style="font-weight: bold;">0 B</span>
                                </div>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                    <span style="color: #666;">è¾“å‡ºå›¾ç‰‡æ•°æ®å¤§å°ï¼š</span>
                                    <span class="output-size" style="font-weight: bold;">0 B</span>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span style="color: #666;">å‹ç¼©ç‡ï¼š</span>
                                    <span class="compression-ratio" style="font-weight: bold;">0%</span>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; margin-top: 15px;">
                                <input type="checkbox" class="combine-as-array" checked style="width: 18px; height: 18px; margin: 0; cursor: pointer;">
                                <span>ç»„åˆä¸ºæ•°ç»„</span>
                            </div>
                        </div>

                        <!-- å¡ç‰‡çŠ¶æ€ -->
                        <div class="card-status" style="margin-top: 10px; font-size: 0.8em; color: #999; text-align: right;"></div>
                    </div>
                </div>
            </div>

            <!-- å³ä¾§é¢æ¿ï¼šå…¨å±€è®¾ç½® -->
            <div class="right-panel">
                <!-- å–æ¨¡è®¾ç½® -->
                <div class="section">
                    <h2>å–æ¨¡è®¾ç½®</h2>
                    <div class="select-group">
                        <label for="colorFormat">é¢œè‰²æ ¼å¼</label>
                        <select id="colorFormat">
                            <option value="rgb888">RGB888</option>
                            <option value="rgb565">RGB565</option>
                            <option value="rgb332">RGB332</option>
                            <option value="argb8888">ARGB8888</option>
                            <option value="argb4444">ARGB4444</option>
                            <option value="argb2222">ARGB2222</option>
                        </select>
                    </div>
                    <div class="select-group">
                        <label for="outputFormat">è¾“å‡ºæ ¼å¼</label>
                        <select id="outputFormat">
                            <option value=".c">.c æ–‡ä»¶</option>
                            <option value=".bin">.bin æ–‡ä»¶</option>
                        </select>
                    </div>
                    <div class="select-group">
                        <label for="compressionAlgorithm">å‹ç¼©ç®—æ³•</label>
                        <select id="compressionAlgorithm">
                            <option value="none" selected>æ— å‹ç¼©</option>
                            <option value="rle">RLE å‹ç¼©</option>
                        </select>
                    </div>
                    <div class="select-group">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <input type="checkbox" id="reverseOrder" checked style="width: 18px; height: 18px; margin: 0; cursor: pointer;">
                            <span>åå­—åº</span>
                        </div>
                    </div>
                    <div class="select-group">
                        <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                            <input type="checkbox" id="transparentFill" checked style="width: 18px; height: 18px; margin: 0; cursor: pointer;">
                            <span>é€æ˜å¡«å……</span>
                            <input type="text" id="fillColor" value="FFFFFF" placeholder="åå…­è¿›åˆ¶é¢œè‰²å€¼" style="width: 120px; padding: 5px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
                            <div id="colorPreview" style="width: 30px; height: 30px; background-color: #FFFFFF; border: 1px solid #ccc; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.2); margin-left: 5px;"></div>
                        </div>
                    </div>

                    <div class="select-group">
                        <label>é¢œè‰²æ·±åº¦</label>
                        <div style="display: flex; flex-direction: column; gap: 15px; margin-bottom: 5px;">
                            <!-- å½“å‰RGBç»„åˆæ˜¾ç¤º -->
                            <div style="display: flex; justify-content: center; align-items: center;">
                                <span id="colorDepthValue" style="font-weight: bold; font-size: 1.2em; min-width: 80px; text-align: center; background: #f0f0f0; padding: 5px 15px; border-radius: 5px;">RGB888</span>
                            </div>

                            <!-- çº¢è‰²é€šé“ -->
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <label for="rDepth" style="min-width: 30px; color: #ff4444;">R:</label>
                                <input type="range" id="rDepth" min="0" max="8" value="8" step="1" style="flex: 1;">
                                <span id="rDepthValue" style="font-weight: bold; min-width: 20px; text-align: center;">8</span>
                            </div>

                            <!-- ç»¿è‰²é€šé“ -->
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <label for="gDepth" style="min-width: 30px; color: #44ff44;">G:</label>
                                <input type="range" id="gDepth" min="0" max="8" value="8" step="1" style="flex: 1;">
                                <span id="gDepthValue" style="font-weight: bold; min-width: 20px; text-align: center;">8</span>
                            </div>

                            <!-- è“è‰²é€šé“ -->
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <label for="bDepth" style="min-width: 30px; color: #4444ff;">B:</label>
                                <input type="range" id="bDepth" min="0" max="8" value="8" step="1" style="flex: 1;">
                                <span id="bDepthValue" style="font-weight: bold; min-width: 20px; text-align: center;">8</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- æ–‡ä»¶åè®¾ç½® -->
                <div class="section">
                    <h2>æ–‡ä»¶åè®¾ç½®</h2>
                    <div class="filename-input-group">
                        <label for="filename">æ–‡ä»¶å</label>
                        <input type="text" id="filename" value="images" placeholder="è¯·è¾“å…¥æ–‡ä»¶å">
                    </div>
                </div>

                <!-- è½¬æ¢æŒ‰é’®å’Œè¿›åº¦æ¡ -->
                <div class="section">
                    <!-- è¿›åº¦æ¡ -->
                    <div id="progressContainer" class="progress-container">
                        <div class="progress-info">
                            <span id="progressText">å‡†å¤‡è½¬æ¢...</span>
                            <span id="progressPercent">0%</span>
                        </div>
                        <div class="progress-bar">
                            <div id="progressFill" class="progress-fill"></div>
                        </div>
                    </div>

                    <!-- æŒ‰é’®å®¹å™¨ -->
                    <div style="display: flex; gap: 15px;">
                        <button id="exportPreviewBtn" class="convert-btn" disabled style="flex: 1;">å¯¼å‡ºé¢„è§ˆ</button>
                        <button id="convertBtn" class="convert-btn" disabled style="flex: 1;">å¼€å§‹è½¬æ¢</button>
                    </div>
                </div>
            </div>
        </div>


    </div>

    <!-- å¯¼å‡ºé¢„è§ˆå¼¹çª— -->
    <div id="previewModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 10000; justify-content: center; align-items: center;">
        <div id="previewModalContent" style="background: white; border-radius: 20px; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3); overflow: hidden; max-width: 80vw; max-height: 90vh;">
            <!-- å¼¹çª—å¤´éƒ¨ -->
            <div style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); padding: 20px; display: flex; justify-content: space-between; align-items: center; color: white;">
                <h2 style="margin: 0; font-size: 1.5em; font-weight: 700;">å¯¼å‡ºé¢„è§ˆ</h2>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button id="copyButton" style="padding: 10px 20px; background: rgba(255, 255, 255, 0.9); color: #4facfe; border: none; border-radius: 8px; font-size: 0.9em; font-weight: 600; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);">ä¸€é”®å¤åˆ¶</button>
                    <button id="closeModalButton" style="padding: 10px 20px; background: rgba(255, 87, 34, 0.9); color: white; border: none; border-radius: 8px; font-size: 0.9em; font-weight: 600; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);">å…³é—­</button>
                </div>
            </div>

            <!-- æ ‡ç­¾é¡µ -->
            <div id="previewTabs" style="display: flex; background: #f8f9fa; border-bottom: 2px solid #e0e0e0;"></div>

            <!-- é¢„è§ˆå†…å®¹ -->
            <div id="previewContent" style="padding: 20px; max-height: 70vh; overflow: auto;">
                <pre id="codePreview" style="background: #f0f0f0; padding: 20px; border-radius: 12px; font-family: 'Consolas', 'Monaco', 'Courier New', monospace; font-size: 16px; line-height: 1.4; white-space: pre; max-height: 60vh; overflow: auto; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;"></pre>
            </div>
        </div>
    </div>

    <script>

        // å…¨å±€å˜é‡
        let cards = [];

        // å•å¼ å›¾ç‰‡æ•°æ®ç»“æ„
        class ImageItem {
            constructor() {
                this.file = null;
                this.previewUrl = '';
                this.isValid = false;
            }
        }

        // å¡ç‰‡æ•°æ®ç»“æ„
        class ImageCard {
            constructor(index) {
                this.index = index;
                this.images = []; // å­˜å‚¨å¤šå¼ å›¾ç‰‡
                this.originalWidth = 0;
                this.originalHeight = 0;
                this.aspectRatio = 1;
                this.width = 0;
                this.height = 0;
                this.arrayPrefix = `pic${index + 1}`;
                this.isValid = false;
            }
        }

        // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬
        document.addEventListener('DOMContentLoaded', function() {
            // åˆå§‹åŒ–ç¬¬ä¸€å¼ å¡ç‰‡
            cards.push(new ImageCard(0));
            initCard(0);
            updateArrayPrefix(0, `pic1`);

            // ä¸ºç°æœ‰å¡ç‰‡çš„åˆ é™¤æ‰€æœ‰æŒ‰é’®æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
            document.querySelectorAll('.image-card').forEach(function(cardElement) {
                const cardIndex = parseInt(cardElement.getAttribute('data-card-index'));
                const deleteAllBtns = cardElement.querySelectorAll('.delete-all-btn');
                deleteAllBtns.forEach(function(btn) {
                    btn.addEventListener('click', function() {
                        deleteAllImages(cardIndex);
                    });
                });
            });

            // æ·»åŠ å¡ç‰‡æŒ‰é’®äº‹ä»¶
            document.getElementById('addCardBtn').addEventListener('click', addCard);

            // æ–‡ä»¶åéªŒè¯å’Œè°ƒæ•´
            const filenameInput = document.getElementById('filename');
            filenameInput.addEventListener('input', function(e) {
                let value = e.target.value;

                // ç§»é™¤æ‰€æœ‰éå­—æ¯æ•°å­—å’Œä¸‹åˆ’çº¿çš„å­—ç¬¦
                value = value.replace(/[^a-zA-Z0-9_]/g, '');

                // å¦‚æœä»¥æ•°å­—å¼€å¤´ï¼Œæ·»åŠ ä¸‹åˆ’çº¿
                if (/^\d/.test(value)) {
                    value = '_' + value;
                }

                // å…è®¸ä¸ºç©ºï¼Œä¸è®¾ç½®é»˜è®¤å€¼
                e.target.value = value;
            });

            // è½¬æ¢æŒ‰é’®äº‹ä»¶
            const convertBtn = document.getElementById('convertBtn');
            convertBtn.addEventListener('click', convertAllImages);

            // å¯¼å‡ºé¢„è§ˆæŒ‰é’®äº‹ä»¶
            const exportPreviewBtn = document.getElementById('exportPreviewBtn');
            exportPreviewBtn.addEventListener('click', exportPreview);

            // é¢œè‰²æ ¼å¼å˜åŒ–äº‹ä»¶
            const colorFormatSelect = document.getElementById('colorFormat');
            colorFormatSelect.addEventListener('change', function() {
                updateChannelValuesByFormat();
                updateAllOutputDetails();

                // æ§åˆ¶é€æ˜å¡«å……é€‰é¡¹çš„çŠ¶æ€
                const transparentFillCheckbox = document.getElementById('transparentFill');
                const fillColorInput = document.getElementById('fillColor');
                const colorPreview = document.getElementById('colorPreview');

                if (this.value === 'argb8888' || this.value === 'argb4444' || this.value === 'argb2222') {
                    // ARGBæ ¼å¼ä¸éœ€è¦é€æ˜å¡«å……
                    transparentFillCheckbox.checked = false;
                    transparentFillCheckbox.disabled = true;
                    fillColorInput.disabled = true;
                    colorPreview.style.opacity = '0.5';
                } else {
                    // å…¶ä»–æ ¼å¼éœ€è¦é€æ˜å¡«å……
                    transparentFillCheckbox.checked = true;
                    transparentFillCheckbox.disabled = false;
                    fillColorInput.disabled = false;
                    colorPreview.style.opacity = '1';
                }

                // é‡æ–°æ£€æŸ¥æŒ‰é’®çŠ¶æ€
                checkConvertButtonState();
            });

            // è¾“å‡ºæ ¼å¼å˜åŒ–äº‹ä»¶
            const outputFormatSelect = document.getElementById('outputFormat');
            outputFormatSelect.addEventListener('change', function() {
                updateAllOutputDetails();
                // é‡æ–°æ£€æŸ¥æŒ‰é’®çŠ¶æ€
                checkConvertButtonState();
            });

            // å‹ç¼©ç®—æ³•å˜åŒ–äº‹ä»¶
            const compressionAlgorithmSelect = document.getElementById('compressionAlgorithm');
            compressionAlgorithmSelect.addEventListener('change', function() {
                updateAllOutputDetails();
                // é‡æ–°æ£€æŸ¥æŒ‰é’®çŠ¶æ€
                checkConvertButtonState();
            });

            // é¢œè‰²æ·±åº¦æ»‘å—äº‹ä»¶
            const rSlider = document.getElementById('rDepth');
            const gSlider = document.getElementById('gDepth');
            const bSlider = document.getElementById('bDepth');

            // ä¸ºæ¯ä¸ªæ»‘å—æ·»åŠ äº‹ä»¶ç›‘å¬
            rSlider.addEventListener('input', function() {
                const { rMax } = getChannelMaxValue();
                if (parseInt(this.value) > rMax) {
                    this.value = rMax;
                }
                updateChannelValue('r');
                updateColorDepthValue();
                updateAllOutputPreviews();
                updateAllOutputDetails();
                // é‡æ–°æ£€æŸ¥æŒ‰é’®çŠ¶æ€
                checkConvertButtonState();
            });

            gSlider.addEventListener('input', function() {
                const { gMax } = getChannelMaxValue();
                if (parseInt(this.value) > gMax) {
                    this.value = gMax;
                }
                updateChannelValue('g');
                updateColorDepthValue();
                updateAllOutputPreviews();
                updateAllOutputDetails();
                // é‡æ–°æ£€æŸ¥æŒ‰é’®çŠ¶æ€
                checkConvertButtonState();
            });

            bSlider.addEventListener('input', function() {
                const { bMax } = getChannelMaxValue();
                if (parseInt(this.value) > bMax) {
                    this.value = bMax;
                }
                updateChannelValue('b');
                updateColorDepthValue();
                updateAllOutputPreviews();
                updateAllOutputDetails();
                // é‡æ–°æ£€æŸ¥æŒ‰é’®çŠ¶æ€
                checkConvertButtonState();
            });

            // åˆå§‹åŒ–é¢œè‰²æ·±åº¦æ˜¾ç¤º
            updateColorDepthValue();

            // é€æ˜å¡«å……åŠŸèƒ½åˆå§‹åŒ–
            const transparentFillCheckbox = document.getElementById('transparentFill');
            const fillColorInput = document.getElementById('fillColor');
            const colorPreview = document.getElementById('colorPreview');

            // åˆå§‹åŒ–é€æ˜å¡«å……é€‰é¡¹çš„çŠ¶æ€
            const initialColorFormat = document.getElementById('colorFormat').value;
            if (initialColorFormat === 'argb8888' || initialColorFormat === 'argb4444') {
                // ARGBæ ¼å¼ä¸éœ€è¦é€æ˜å¡«å……
                transparentFillCheckbox.checked = false;
                transparentFillCheckbox.disabled = true;
                fillColorInput.disabled = true;
                colorPreview.style.opacity = '0.5';
            } else {
                // å…¶ä»–æ ¼å¼éœ€è¦é€æ˜å¡«å……
                transparentFillCheckbox.checked = true;
                transparentFillCheckbox.disabled = false;
                fillColorInput.disabled = false;
                colorPreview.style.opacity = '1';
            }

            // æ›´æ–°é¢œè‰²é¢„è§ˆ
            function updateColorPreview() {
                let color = fillColorInput.value.trim().toUpperCase();

                // éªŒè¯é¢œè‰²æ ¼å¼
                if (/^[0-9A-F]{6}$/.test(color)) {
                    // æœ‰æ•ˆçš„6ä½åå…­è¿›åˆ¶é¢œè‰²
                    colorPreview.style.backgroundColor = `#${color}`;
                    fillColorInput.style.borderColor = '#ddd';
                } else {
                    // æ— æ•ˆé¢œè‰²ï¼Œæ˜¾ç¤ºé”™è¯¯è¾¹æ¡†
                    fillColorInput.style.borderColor = '#ff4444';
                }
            }

            // åˆå§‹åŒ–é¢œè‰²é¢„è§ˆ
            updateColorPreview();

            // é¢œè‰²è¾“å…¥æ¡†äº‹ä»¶ç›‘å¬
            fillColorInput.addEventListener('input', function(e) {
                // åªå…è®¸è¾“å…¥åå…­è¿›åˆ¶å­—ç¬¦
                let value = e.target.value.toUpperCase().replace(/[^0-9A-F]/g, '');
                // é™åˆ¶é•¿åº¦ä¸º6ä½
                if (value.length > 6) {
                    value = value.substring(0, 6);
                }
                e.target.value = value;
                updateColorPreview();
            });

            // å¤±å»ç„¦ç‚¹æ—¶è‡ªåŠ¨è¡¥å…¨6ä½
            fillColorInput.addEventListener('blur', function(e) {
                let value = e.target.value.trim().toUpperCase();
                // å¦‚æœè¾“å…¥ä¸ºç©ºæˆ–ä¸è¶³6ä½ï¼Œè‡ªåŠ¨è¡¥å…¨ä¸ºFFFFFF
                if (value.length === 0 || !/^[0-9A-F]{6}$/.test(value)) {
                    e.target.value = 'FFFFFF';
                    updateColorPreview();
                }
            });

            // åˆå§‹åŒ–é¢„è§ˆç”»å¸ƒäº¤äº’åŠŸèƒ½
            initPreviewCanvasInteractions();
        });

        // å±…ä¸­ç”»å¸ƒåŠŸèƒ½
        function centerCanvas(cardIndex) {
            const cardElement = document.querySelector(`[data-card-index="${cardIndex}"]`);

            // å¤„ç†åŸå›¾é¢„è§ˆç”»å¸ƒ
            const originalContainer = cardElement.querySelector('.preview-images');
            if (originalContainer) {
                const containerElement = cardElement.querySelector('.preview-canvas-container');
                const containerWidth = containerElement.clientWidth;
                const containerHeight = containerElement.clientHeight;

                // è®¡ç®—å®é™…å†…å®¹å®½åº¦ï¼ˆè€ƒè™‘gridå¸ƒå±€çš„gapï¼‰
                let canvasWidth = originalContainer.scrollWidth;
                let canvasHeight = originalContainer.scrollHeight;

                // ä¿®å¤ï¼šå½“å›¾ç‰‡æ•°é‡å°‘äº9å¼ æ—¶ï¼Œè®¡ç®—å®é™…å†…å®¹å®½åº¦
                const imageCount = originalContainer.children.length;
                if (imageCount > 0 && imageCount < 9) {
                    const firstImage = originalContainer.firstElementChild;
                    const imageWidth = firstImage.clientWidth;
                    const gap = 8; // ä¸CSSä¸­è®¾ç½®çš„gapä¸€è‡´
                    canvasWidth = (imageWidth * imageCount) + (gap * (imageCount - 1)) + 20; // 20æ˜¯padding
                }

                // è·å–å½“å‰ç¼©æ”¾
                const transform = originalContainer.style.transform;
                let currentScale = 1;
                if (transform) {
                    const scaleMatch = transform.match(/scale\(([^)]+)\)/);
                    if (scaleMatch) {
                        currentScale = parseFloat(scaleMatch[1]);
                    }
                }

                // è®¡ç®—å±…ä¸­ä½ç½®
                const centerX = (containerWidth - canvasWidth) / 2;
                const centerY = (containerHeight - canvasHeight) / 2;

                // åº”ç”¨å±…ä¸­ä½ç½®
                const newTransform = `translate(${centerX}px, ${centerY}px) scale(${currentScale})`;
                originalContainer.style.transform = newTransform;
            }

            // å¤„ç†è¾“å‡ºé¢„è§ˆç”»å¸ƒ
            const outputContainer = cardElement.querySelector('.output-preview-images');
            if (outputContainer) {
                const containerElement = cardElement.querySelector('.preview-canvas-container');
                const containerWidth = containerElement.clientWidth;
                const containerHeight = containerElement.clientHeight;

                // è®¡ç®—å®é™…å†…å®¹å®½åº¦ï¼ˆè€ƒè™‘gridå¸ƒå±€çš„gapï¼‰
                let canvasWidth = outputContainer.scrollWidth;
                let canvasHeight = outputContainer.scrollHeight;

                // ä¿®å¤ï¼šå½“å›¾ç‰‡æ•°é‡å°‘äº9å¼ æ—¶ï¼Œè®¡ç®—å®é™…å†…å®¹å®½åº¦
                const imageCount = outputContainer.children.length;
                if (imageCount > 0 && imageCount < 9) {
                    const firstImage = outputContainer.firstElementChild;
                    const imageWidth = firstImage.clientWidth;
                    const gap = 8; // ä¸CSSä¸­è®¾ç½®çš„gapä¸€è‡´
                    canvasWidth = (imageWidth * imageCount) + (gap * (imageCount - 1)) + 20; // 20æ˜¯padding
                }

                // è·å–å½“å‰ç¼©æ”¾
                const transform = outputContainer.style.transform;
                let currentScale = 1;
                if (transform) {
                    const scaleMatch = transform.match(/scale\(([^)]+)\)/);
                    if (scaleMatch) {
                        currentScale = parseFloat(scaleMatch[1]);
                    }
                }

                // è®¡ç®—å±…ä¸­ä½ç½®
                const centerX = (containerWidth - canvasWidth) / 2;
                const centerY = (containerHeight - canvasHeight) / 2;

                // åº”ç”¨å±…ä¸­ä½ç½®
                const newTransform = `translate(${centerX}px, ${centerY}px) scale(${currentScale})`;
                outputContainer.style.transform = newTransform;
            }
        }

        // ä¸ºé¢„è§ˆå®¹å™¨æ·»åŠ æ»šè½®ç¼©æ”¾äº‹ä»¶
        function addWheelListener(container) {
            container.addEventListener('wheel', function(e) {
                // é˜»æ­¢é»˜è®¤è¡Œä¸ºå’Œäº‹ä»¶å†’æ³¡
                e.preventDefault();
                e.stopPropagation();

                // è·å–ç”»å¸ƒå…ƒç´ 
                const canvas = container.querySelector('.preview-images, .output-preview-images');
                if (!canvas) return;

                // è®¡ç®—ç¼©æ”¾å› å­
                const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;

                // è·å–å½“å‰ç¼©æ”¾å’Œä½ç½®
                const transform = canvas.style.transform;
                let currentScale = 1;
                let currentX = 0;
                let currentY = 0;

                if (transform) {
                    const scaleMatch = transform.match(/scale\(([^)]+)\)/);
                    const translateMatch = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);

                    if (scaleMatch) {
                        currentScale = parseFloat(scaleMatch[1]);
                    }

                    if (translateMatch) {
                        currentX = parseFloat(translateMatch[1]);
                        currentY = parseFloat(translateMatch[2]);
                    }
                }

                // è®¡ç®—æ–°ç¼©æ”¾
                const newScale = Math.max(0.1, Math.min(5, currentScale * scaleFactor));

                // åº”ç”¨æ–°ç¼©æ”¾
                const newTransform = `translate(${currentX}px, ${currentY}px) scale(${newScale})`;
                canvas.style.transform = newTransform;

                // åŒæ­¥åˆ°å¯¹åº”é¢„è§ˆå®¹å™¨
                const cardElement = container.closest('[data-card-index]');
                if (cardElement) {
                    const isOriginal = container.querySelector('.preview-images');

                    // è·å–å¯¹åº”é¢„è§ˆå®¹å™¨
                    const targetContainer = isOriginal ?
                        cardElement.querySelector('.output-preview-images') :
                        cardElement.querySelector('.preview-images');

                    if (targetContainer) {
                        targetContainer.style.transform = newTransform;
                    }
                }
            }, { passive: false });
        }

        // åˆå§‹åŒ–é¢„è§ˆç”»å¸ƒäº¤äº’åŠŸèƒ½
        function initPreviewCanvasInteractions() {
            // ä¸ºæ‰€æœ‰é¢„è§ˆå®¹å™¨æ·»åŠ äº‹ä»¶ç›‘å¬
            document.addEventListener('mousedown', function(e) {
                // åªå¤„ç†å³é”®æ‹–æ‹½ï¼Œå·¦é”®é•¿æŒ‰æ— æ•ˆæœ
                if (e.button !== 2) return;

                // é˜»æ­¢å³é”®èœå•å¼¹å‡º
                e.preventDefault();

                // æ£€æŸ¥æ˜¯å¦åœ¨é¢„è§ˆå®¹å™¨å†…
                const container = e.target.closest('.preview-canvas-container');
                if (!container) return;

                // è·å–ç”»å¸ƒå…ƒç´ 
                const canvas = container.querySelector('.preview-images, .output-preview-images');
                if (!canvas) return;

                // å¼€å§‹æ‹–æ‹½
                let isDragging = true;
                let startX = e.clientX;
                let startY = e.clientY;

                // è·å–å½“å‰ä½ç½®
                const transform = canvas.style.transform;
                let currentX = 0;
                let currentY = 0;

                if (transform) {
                    const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
                    if (match) {
                        currentX = parseFloat(match[1]);
                        currentY = parseFloat(match[2]);
                    }
                }

                // æ›´æ–°é¼ æ ‡æ ·å¼
                container.style.cursor = 'grabbing';

                // é¼ æ ‡ç§»åŠ¨äº‹ä»¶
                function onMouseMove(e) {
                    if (!isDragging) return;

                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;

                    // è·å–å½“å‰ç¼©æ”¾
                    const transform = canvas.style.transform;
                    let currentScale = 1;
                    if (transform) {
                        const scaleMatch = transform.match(/scale\(([^)]+)\)/);
                        if (scaleMatch) {
                            currentScale = parseFloat(scaleMatch[1]);
                        }
                    }

                    // è®¡ç®—ç”»å¸ƒå†…å®¹å°ºå¯¸
                    const canvasWidth = canvas.scrollWidth;
                    const canvasHeight = canvas.scrollHeight;

                    // è®¡ç®—å®¹å™¨å°ºå¯¸ï¼ˆç”¨äºåç»­çš„å±…ä¸­åŠŸèƒ½ï¼‰
                    const containerWidth = container.clientWidth;
                    const containerHeight = container.clientHeight;

                    // ç§»é™¤è¾¹ç•Œé™åˆ¶ï¼Œè®©ç”¨æˆ·å¯ä»¥éšæ„ç§»åŠ¨ç”»å¸ƒ
                    let newX = currentX + deltaX;
                    let newY = currentY + deltaY;

                    // åº”ç”¨æ–°ä½ç½®åˆ°å½“å‰ç”»å¸ƒ
                    let scalePart = '';
                    if (transform) {
                        const scaleMatch = transform.match(/scale\(([^)]+)\)/);
                        if (scaleMatch) {
                            scalePart = ` scale(${scaleMatch[1]})`;
                        }
                    }
                    const newTransform = `translate(${newX}px, ${newY}px)${scalePart}`;
                    canvas.style.transform = newTransform;

                    // æ›´æ–°èµ·å§‹ä½ç½®ï¼Œä»¥ä¾¿ä¸‹æ¬¡è®¡ç®—
                    startX = e.clientX;
                    startY = e.clientY;
                    currentX = newX;
                    currentY = newY;

                    // åŒæ­¥åˆ°å¯¹åº”é¢„è§ˆå®¹å™¨
                    const cardElement = container.closest('[data-card-index]');
                    if (cardElement) {
                        const cardIndex = cardElement.dataset.cardIndex;
                        const isOriginal = container.querySelector('.preview-images');

                        // è·å–å¯¹åº”é¢„è§ˆå®¹å™¨
                        const targetContainer = isOriginal ?
                            cardElement.querySelector('.output-preview-images') :
                            cardElement.querySelector('.preview-images');

                        if (targetContainer) {
                            targetContainer.style.transform = newTransform;
                        }
                    }
                }

                // é¼ æ ‡é‡Šæ”¾äº‹ä»¶
                function onMouseUp() {
                    isDragging = false;
                    container.style.cursor = 'grab';
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                }

                // æ·»åŠ äº‹ä»¶ç›‘å¬
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });

            // ä¸ºæ‰€æœ‰ç°æœ‰çš„é¢„è§ˆå®¹å™¨æ·»åŠ æ»šè½®äº‹ä»¶ç›‘å¬å™¨
            document.querySelectorAll('.preview-canvas-container').forEach(addWheelListener);

            // ç§»é™¤åŒå‡»ç©ºç™½å¤„è‡ªåŠ¨å±…ä¸­åŠŸèƒ½ï¼Œæ”¹ä¸ºä½¿ç”¨å±…ä¸­ç”»å¸ƒæŒ‰é’®

            // ç¦æ­¢é¢„è§ˆå®¹å™¨çš„å³é”®èœå•
            document.addEventListener('contextmenu', function(e) {
                if (e.target.closest('.preview-canvas-container')) {
                    e.preventDefault();
                }
            });
        }

        // æ›´æ–°å•ä¸ªé€šé“çš„å€¼æ˜¾ç¤º
        function updateChannelValue(channel) {
            const slider = document.getElementById(`${channel}Depth`);
            const valueDisplay = document.getElementById(`${channel}DepthValue`);
            valueDisplay.textContent = slider.value;
        }

        // åº”ç”¨é¢œè‰²æ·±åº¦è¿‡æ»¤åˆ°å›¾ç‰‡æ•°æ®
        function processImageData(imageData, format) {
            const data = imageData.data;

            // è·å–å½“å‰é¢œè‰²æ·±åº¦è®¾ç½®
            const rBits = parseInt(document.getElementById('rDepth').value);
            const gBits = parseInt(document.getElementById('gDepth').value);
            const bBits = parseInt(document.getElementById('bDepth').value);

            // é™ä½é¢œè‰²æ·±åº¦
            for (let i = 0; i < data.length; i += 4) {
                // çº¢è‰²é€šé“
                const r = data[i];
                let newR;
                if (rBits === 0) {
                    newR = 0;
                } else {
                    const rShift = 8 - rBits;
                    newR = Math.round((r >> rShift) << rShift);
                }
                data[i] = newR;

                // ç»¿è‰²é€šé“
                const g = data[i + 1];
                let newG;
                if (gBits === 0) {
                    newG = 0;
                } else {
                    const gShift = 8 - gBits;
                    newG = Math.round((g >> gShift) << gShift);
                }
                data[i + 1] = newG;

                // è“è‰²é€šé“
                const b = data[i + 2];
                let newB;
                if (bBits === 0) {
                    newB = 0;
                } else {
                    const bShift = 8 - bBits;
                    newB = Math.round((b >> bShift) << bShift);
                }
                data[i + 2] = newB;

                // é€æ˜åº¦é€šé“ä¿æŒä¸å˜
            }

            return imageData;
        }

        // å°†å­—èŠ‚æ•°è½¬æ¢ä¸ºäººç±»å¯è¯»æ ¼å¼
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // å¹¶å‘æ§åˆ¶å‡½æ•°ï¼Œç”¨äºé™åˆ¶åŒæ—¶å¤„ç†çš„å›¾ç‰‡æ•°é‡




        // æ›´æ–°å•å¼ å¡ç‰‡çš„è¾“å‡ºè¯¦æƒ…
        function updateOutputDetails(cardIndex) {
            const card = cards[cardIndex];
            const cardElement = document.querySelector(`[data-card-index="${cardIndex}"]`);
            if (!cardElement) return;

            // å½“å¡ç‰‡ä¸­æ²¡æœ‰å›¾ç‰‡æ—¶ï¼Œé‡ç½®è¾“å‡ºè¯¦æƒ…ä¸º0
            if (!card.isValid || card.images.length === 0 || !card.images[0].previewUrl) {
                // æ›´æ–°UIæ˜¾ç¤ºä¸º0
                cardElement.querySelector('.original-size').textContent = formatBytes(0);
                cardElement.querySelector('.output-size').textContent = formatBytes(0);
                cardElement.querySelector('.compression-ratio').textContent = `0%`;
                return;
            }

            // è·å–å½“å‰å–æ¨¡è®¾ç½®
            const colorFormat = document.getElementById('colorFormat').value;
            const compressionAlgorithm = document.getElementById('compressionAlgorithm').value;

            // è®¡ç®—æ¯åƒç´ å­—èŠ‚æ•°
            let bytesPerPixel = 3; // é»˜è®¤RGB888
            if (colorFormat === 'rgb565') {
                bytesPerPixel = 2;
            } else if (colorFormat === 'rgb332') {
                bytesPerPixel = 1;
            } else if (colorFormat === 'argb8888') {
                bytesPerPixel = 4;
            } else if (colorFormat === 'argb4444') {
                bytesPerPixel = 2;
            } else if (colorFormat === 'argb2222') {
                bytesPerPixel = 1;
            }

            // è®¡ç®—å•å¼ å›¾ç‰‡çš„å¤§å°
            const singleImageOriginalSize = card.width * card.height * bytesPerPixel;

            // è®¡ç®—æ‰€æœ‰å›¾ç‰‡çš„åŸå›¾æ€»å¤§å°
            const totalOriginalSize = singleImageOriginalSize * card.images.length;

            // å¦‚æœä½¿ç”¨RLEå‹ç¼©ï¼Œéœ€è¦è®¡ç®—æ‰€æœ‰å›¾ç‰‡çš„å‹ç¼©å¤§å°
            if (compressionAlgorithm === 'rle') {
                // åˆ›å»ºä¸´æ—¶canvasè·å–å›¾ç‰‡æ•°æ®
                const canvas = document.createElement('canvas');
                canvas.width = card.width;
                canvas.height = card.height;
                const ctx = canvas.getContext('2d');

                // è®¡ç®—ä¸€å¼ å›¾ç‰‡çš„å‹ç¼©å¤§å°ï¼Œç„¶åä¹˜ä»¥å›¾ç‰‡æ•°é‡
                const img = new Image();
                img.onload = function() {
                    // æ£€æŸ¥æ˜¯å¦å¯ç”¨é€æ˜å¡«å……
                    const useTransparentFill = document.getElementById('transparentFill').checked;
                    let fillR = 255, fillG = 255, fillB = 255;

                    if (useTransparentFill) {
                        // è·å–å¡«å……é¢œè‰²
                        const fillColor = document.getElementById('fillColor').value.trim().toUpperCase();
                        if (/^[0-9A-F]{6}$/.test(fillColor)) {
                            // è§£æRGBå€¼
                            fillR = parseInt(fillColor.substring(0, 2), 16);
                            fillG = parseInt(fillColor.substring(2, 4), 16);
                            fillB = parseInt(fillColor.substring(4, 6), 16);
                        }
                    }

                    // å¦‚æœå¯ç”¨é€æ˜å¡«å……ï¼Œå…ˆç»˜åˆ¶å¡«å……é¢œè‰²ï¼Œå†ç»˜åˆ¶å›¾ç‰‡
                    if (useTransparentFill) {
                        // ç»˜åˆ¶å¡«å……é¢œè‰²
                        ctx.fillStyle = `rgb(${fillR}, ${fillG}, ${fillB})`;
                        ctx.fillRect(0, 0, card.width, card.height);
                        // ç»˜åˆ¶å›¾ç‰‡ï¼ˆä¼šä¸èƒŒæ™¯è‰²æ··åˆé€æ˜åƒç´ ï¼‰
                        ctx.drawImage(img, 0, 0, card.width, card.height);
                    } else {
                        // ç›´æ¥ç»˜åˆ¶å›¾ç‰‡
                        ctx.drawImage(img, 0, 0, card.width, card.height);
                    }

                    // è·å–å›¾ç‰‡æ•°æ®å¹¶åº”ç”¨é¢œè‰²æ·±åº¦è¿‡æ»¤
                    let imageData = ctx.getImageData(0, 0, card.width, card.height);
                    imageData = processImageData(imageData, colorFormat);
                    const data = imageData.data;

                    // ç”Ÿæˆåƒç´ æ•°æ®æ•°ç»„
                    const pixelBytes = [];

                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const a = data[i + 3];

                        if (colorFormat === 'rgb888') {
                            // æ£€æŸ¥åå­—åºè®¾ç½®
                            const isReverseOrder = document.getElementById('reverseOrder').checked;
                            if (isReverseOrder) {
                                // BGRé¡ºåº
                                pixelBytes.push(b);
                                pixelBytes.push(g);
                                pixelBytes.push(r);
                            } else {
                                // RGBé¡ºåº
                                pixelBytes.push(r);
                                pixelBytes.push(g);
                                pixelBytes.push(b);
                            }
                        } else if (colorFormat === 'rgb565') {
                            const r5 = (r >> 3) & 0x1F;
                            const g6 = (g >> 2) & 0x3F;
                            const b5 = (b >> 3) & 0x1F;
                            const value = (r5 << 11) | (g6 << 5) | b5;
                            const lowByte = value & 0xFF;
                            const highByte = (value >> 8) & 0xFF;

                            // æ£€æŸ¥åå­—åºè®¾ç½®
                            const isLittleEndian = document.getElementById('reverseOrder').checked;
                            if (isLittleEndian) {
                                // ä½å­—èŠ‚åœ¨å‰ï¼Œé«˜å­—èŠ‚åœ¨åï¼ˆå°ç«¯åºï¼‰
                                pixelBytes.push(lowByte);
                                pixelBytes.push(highByte);
                            } else {
                                // é«˜å­—èŠ‚åœ¨å‰ï¼Œä½å­—èŠ‚åœ¨åï¼ˆå¤§ç«¯åºï¼‰
                                pixelBytes.push(highByte);
                                pixelBytes.push(lowByte);
                            }
                        } else if (colorFormat === 'rgb332') {
                            const r3 = (r >> 5) & 0x07;
                            const g3 = (g >> 5) & 0x07;
                            const b2 = (b >> 6) & 0x03;
                            const value = (r3 << 5) | (g3 << 2) | b2;
                            pixelBytes.push(value);
                        } else if (colorFormat === 'argb8888') {
                            // æ£€æŸ¥åå­—åºè®¾ç½®
                            const isReverseOrder = document.getElementById('reverseOrder').checked;
                            if (isReverseOrder) {
                                // B+G+R+Aé¡ºåº
                                pixelBytes.push(b);
                                pixelBytes.push(g);
                                pixelBytes.push(r);
                                pixelBytes.push(a);
                            } else {
                                // A+R+G+Bé¡ºåº
                                pixelBytes.push(a);
                                pixelBytes.push(r);
                                pixelBytes.push(g);
                                pixelBytes.push(b);
                            }
                        } else if (colorFormat === 'argb4444') {
                            // ARGB4444æ ¼å¼ï¼š2å­—èŠ‚ï¼ŒA(4bit),R(4bit),G(4bit),B(4bit)
                            const a4 = (a >> 4) & 0x0F;
                            const r4 = (r >> 4) & 0x0F;
                            const g4 = (g >> 4) & 0x0F;
                            const b4 = (b >> 4) & 0x0F;
                            const value = (a4 << 12) | (r4 << 8) | (g4 << 4) | b4;
                            const lowByte = value & 0xFF;
                            const highByte = (value >> 8) & 0xFF;

                            // æ£€æŸ¥åå­—åºè®¾ç½®
                            const isReverseOrder = document.getElementById('reverseOrder').checked;
                            if (isReverseOrder) {
                                // ä½å­—èŠ‚åœ¨å‰ï¼Œé«˜å­—èŠ‚åœ¨åï¼ˆå°ç«¯åºï¼‰
                                pixelBytes.push(lowByte);
                                pixelBytes.push(highByte);
                            } else {
                                // é«˜å­—èŠ‚åœ¨å‰ï¼Œä½å­—èŠ‚åœ¨åï¼ˆå¤§ç«¯åºï¼‰
                                pixelBytes.push(highByte);
                                pixelBytes.push(lowByte);
                            }
                        } else if (colorFormat === 'argb2222') {
                            // ARGB2222æ ¼å¼ï¼š1å­—èŠ‚ï¼ŒA(2bit),R(2bit),G(2bit),B(2bit)
                            const a2 = (a >> 6) & 0x03;
                            const r2 = (r >> 6) & 0x03;
                            const g2 = (g >> 6) & 0x03;
                            const b2 = (b >> 6) & 0x03;
                            const value = (a2 << 6) | (r2 << 4) | (g2 << 2) | b2;
                            pixelBytes.push(value);
                        }
                    }

                    // åº”ç”¨RLEå‹ç¼©
                    const compressed = rleCompress(pixelBytes, colorFormat);
                    const singleImageOutputSize = compressed.length;

                    // è®¡ç®—æ‰€æœ‰å›¾ç‰‡çš„è¾“å‡ºæ€»å¤§å°
                    const totalOutputSize = singleImageOutputSize * card.images.length;

                    // è®¡ç®—æ€»å‹ç¼©ç‡
                    const compressionRatio = totalOriginalSize > 0 ? ((totalOriginalSize - totalOutputSize) / totalOriginalSize * 100).toFixed(2) : 0;

                    // æ›´æ–°UIæ˜¾ç¤º
                    cardElement.querySelector('.original-size').textContent = formatBytes(totalOriginalSize);
                    cardElement.querySelector('.output-size').textContent = formatBytes(totalOutputSize);
                    cardElement.querySelector('.compression-ratio').textContent = `${compressionRatio}%`;
                };
                img.src = card.images[0].previewUrl;
            } else {
                // æ— å‹ç¼©æƒ…å†µï¼Œæ‰€æœ‰å›¾ç‰‡è¾“å‡ºå¤§å°ç­‰äºåŸå›¾å¤§å°
                const totalOutputSize = totalOriginalSize;
                const compressionRatio = 0;

                // æ›´æ–°UIæ˜¾ç¤º
                cardElement.querySelector('.original-size').textContent = formatBytes(totalOriginalSize);
                cardElement.querySelector('.output-size').textContent = formatBytes(totalOutputSize);
                cardElement.querySelector('.compression-ratio').textContent = `${compressionRatio}%`;
            }
        }

        // æ›´æ–°æ‰€æœ‰å¡ç‰‡çš„è¾“å‡ºè¯¦æƒ…
        function updateAllOutputDetails() {
            for (let i = 0; i < cards.length; i++) {
                updateOutputDetails(i);
            }
        }

        // æ›´æ–°é¢œè‰²æ·±åº¦æ˜¾ç¤ºå€¼
        function updateColorDepthValue() {
            const r = document.getElementById('rDepth').value;
            const g = document.getElementById('gDepth').value;
            const b = document.getElementById('bDepth').value;
            const colorFormat = document.getElementById('colorFormat').value;
            const colorDepthValue = document.getElementById('colorDepthValue');

            if (colorFormat === 'argb8888' || colorFormat === 'argb4444') {
                colorDepthValue.textContent = `ARGB${r}${g}${b}`;
            } else {
                colorDepthValue.textContent = `RGB${r}${g}${b}`;
            }
        }

        // è·å–å„é€šé“çš„æœ€å¤§å…è®¸å€¼
        function getChannelMaxValue() {
            const colorFormat = document.getElementById('colorFormat').value;
            let rMax = 8, gMax = 8, bMax = 8;

            // æ ¹æ®é¢œè‰²æ ¼å¼è®¾ç½®å„é€šé“çš„æœ€å¤§å…è®¸å€¼
            if (colorFormat === 'rgb565') {
                rMax = 5;
                gMax = 6;
                bMax = 5;
            } else if (colorFormat === 'rgb332') {
                rMax = 3;
                gMax = 3;
                bMax = 2;
            } else if (colorFormat === 'argb8888') {
                // ARGB8888æ ¼å¼ï¼Œå„é€šé“éƒ½æ˜¯8ä½
                rMax = 8;
                gMax = 8;
                bMax = 8;
            } else if (colorFormat === 'argb4444') {
                // ARGB4444æ ¼å¼ï¼Œå„é€šé“éƒ½æ˜¯4ä½
                rMax = 4;
                gMax = 4;
                bMax = 4;
            } else if (colorFormat === 'argb2222') {
                // ARGB2222æ ¼å¼ï¼Œå„é€šé“éƒ½æ˜¯2ä½
                rMax = 2;
                gMax = 2;
                bMax = 2;
            }

            return { rMax, gMax, bMax };
        }

        // æ ¹æ®é¢œè‰²æ ¼å¼æ›´æ–°å„é€šé“çš„å€¼
        function updateChannelValuesByFormat() {
            const { rMax, gMax, bMax } = getChannelMaxValue();

            const rSlider = document.getElementById('rDepth');
            const gSlider = document.getElementById('gDepth');
            const bSlider = document.getElementById('bDepth');

            // ç›´æ¥å°†å„é€šé“å€¼é‡ç½®åˆ°å¯¹åº”é¢œè‰²æ ¼å¼çš„æœ€å¤§å€¼
            rSlider.value = rMax;
            updateChannelValue('r');

            gSlider.value = gMax;
            updateChannelValue('g');

            bSlider.value = bMax;
            updateChannelValue('b');

            // æ›´æ–°é¢œè‰²æ·±åº¦æ˜¾ç¤ºå’Œè¾“å‡ºé¢„è§ˆ
            updateColorDepthValue();
            updateAllOutputPreviews();
        }

        // æ›´æ–°æ‰€æœ‰å¡ç‰‡çš„è¾“å‡ºé¢„è§ˆ
        function updateAllOutputPreviews() {
            for (let i = 0; i < cards.length; i++) {
                // æ— è®ºå¡ç‰‡æ˜¯å¦æœ‰æ•ˆï¼Œéƒ½æ›´æ–°é¢„è§ˆï¼Œç¡®ä¿æ»šåŠ¨æŒ‰é’®æ­£ç¡®æ˜¾ç¤º/éšè—
                updateOriginalPreviews(i);
                updateOutputPreview(i);
            }
        }

        // è°ƒæ•´é¢„è§ˆçª—å£å¤§å°
        function adjustPreviewHeight(cardIndex, isExpanded) {
            const cardElement = document.querySelector(`[data-card-index="${cardIndex}"]`);
            if (!cardElement) return;

            // è·å–åŸå›¾é¢„è§ˆå’Œè¾“å‡ºé¢„è§ˆçš„å®¹å™¨
            const previewContainers = cardElement.querySelectorAll('.preview-canvas-container');
            if (previewContainers.length < 2) return;

            // è®¾ç½®é«˜åº¦
            const height = isExpanded ? '150px' : '75px';
            previewContainers[0].style.height = height;
            previewContainers[1].style.height = height;
        }

        // åˆ é™¤å›¾ç‰‡
        function deleteImage(cardIndex, imageIndex) {
            const card = cards[cardIndex];
            if (!card || imageIndex < 0 || imageIndex >= card.images.length) return;

            // ä»æ•°ç»„ä¸­ç§»é™¤å›¾ç‰‡
            card.images.splice(imageIndex, 1);

            // æ›´æ–°å¡ç‰‡çŠ¶æ€
            card.isValid = card.images.length > 0;

            // å¦‚æœåˆ é™¤åæ²¡æœ‰å›¾ç‰‡äº†ï¼Œé‡ç½®å¡ç‰‡å°ºå¯¸
            if (card.images.length === 0) {
                card.originalWidth = 0;
                card.originalHeight = 0;
                card.aspectRatio = 1;
                card.width = 0;
                card.height = 0;

                // é‡ç½®å°ºå¯¸è¾“å…¥æ¡†
                const cardElement = document.querySelector(`[data-card-index="${cardIndex}"]`);
                const widthInput = cardElement.querySelector('.width-input');
                const heightInput = cardElement.querySelector('.height-input');
                widthInput.value = '';
                heightInput.value = '';
                widthInput.disabled = true;
                heightInput.disabled = true;
            }

            // æ›´æ–°å›¾ç‰‡æ•°é‡æ˜¾ç¤º
            updateImageCountDisplay(cardIndex);

            // æ›´æ–°åŸå›¾é¢„è§ˆ
            updateOriginalPreviews(cardIndex);

            // æ›´æ–°è¾“å‡ºé¢„è§ˆ
            updateOutputPreview(cardIndex);

            // æ›´æ–°è¾“å‡ºè¯¦æƒ…
            updateOutputDetails(cardIndex);

            // æ›´æ–°å¡ç‰‡çŠ¶æ€æ˜¾ç¤º
            const cardElement = document.querySelector(`[data-card-index="${cardIndex}"]`);
            if (card.images.length > 0) {
                updateCardStatus(cardIndex, `âœ… å·²æ·»åŠ  ${card.images.length} å¼ å›¾ç‰‡`);
            } else {
                updateCardStatus(cardIndex, '');
            }

            // æ£€æŸ¥è½¬æ¢æŒ‰é’®çŠ¶æ€
            checkConvertButtonState();
        }

        // åˆ é™¤æ‰€æœ‰å›¾ç‰‡
        function deleteAllImages(cardIndex) {
            const card = cards[cardIndex];
            if (!card) return;

            // æ¸…ç©ºå›¾ç‰‡æ•°ç»„
            card.images = [];

            // æ›´æ–°å¡ç‰‡çŠ¶æ€
            card.isValid = false;

            // é‡ç½®å¡ç‰‡å°ºå¯¸
            card.originalWidth = 0;
            card.originalHeight = 0;
            card.aspectRatio = 1;
            card.width = 0;
            card.height = 0;

            // é‡ç½®å°ºå¯¸è¾“å…¥æ¡†
            const cardElement = document.querySelector(`[data-card-index="${cardIndex}"]`);
            const widthInput = cardElement.querySelector('.width-input');
            const heightInput = cardElement.querySelector('.height-input');
            widthInput.value = '';
            heightInput.value = '';
            widthInput.disabled = true;
            heightInput.disabled = true;

            // æ›´æ–°å›¾ç‰‡æ•°é‡æ˜¾ç¤º
            updateImageCountDisplay(cardIndex);

            // æ›´æ–°åŸå›¾é¢„è§ˆ
            updateOriginalPreviews(cardIndex);

            // æ›´æ–°è¾“å‡ºé¢„è§ˆ
            updateOutputPreview(cardIndex);

            // æ›´æ–°è¾“å‡ºè¯¦æƒ…
            updateOutputDetails(cardIndex);

            // æ›´æ–°å¡ç‰‡çŠ¶æ€æ˜¾ç¤º
            updateCardStatus(cardIndex, '');

            // æ£€æŸ¥è½¬æ¢æŒ‰é’®çŠ¶æ€
            checkConvertButtonState();
        }

        // æ›´æ–°å•å¼ å¡ç‰‡çš„åŸå›¾é¢„è§ˆ
        function updateOriginalPreviews(cardIndex) {
            return new Promise((resolve) => {
                const card = cards[cardIndex];
                const cardElement = document.querySelector(`[data-card-index="${cardIndex}"]`);
                const previewContainer = cardElement.querySelector('.preview-images');

                // æ¸…ç©ºç°æœ‰é¢„è§ˆ
                previewContainer.innerHTML = '';

                // æš‚æ—¶éšè—é¢„è§ˆå®¹å™¨ï¼Œé¿å…ç”¨æˆ·çœ‹åˆ°å›¾ç‰‡åŠ è½½è¿‡ç¨‹
                previewContainer.style.opacity = '0';
                previewContainer.style.visibility = 'hidden';

                // è·å–é¢„è§ˆå®¹å™¨çš„é«˜åº¦ï¼Œè®¡ç®—é»˜è®¤ç¼©æ”¾æ¯”ä¾‹ï¼ˆè§†çª—é«˜åº¦çš„50%ï¼‰
                const containerElement = cardElement.querySelector('.preview-canvas-container');
                const containerHeight = containerElement.clientHeight;
                const defaultScaleHeight = containerHeight * 0.5;

                if (card.images.length === 0) {
                    // å¦‚æœæ²¡æœ‰å›¾ç‰‡ï¼Œæ˜¾ç¤ºç©ºå®¹å™¨
                    previewContainer.style.opacity = '1';
                    previewContainer.style.visibility = 'visible';
                    resolve();
                    return;
                }

                let loadedImages = 0;
                const totalImages = card.images.length;

                card.images.forEach((imageItem, index) => {
                    if (imageItem.previewUrl) {
                        // åˆ›å»ºå›¾ç‰‡å®¹å™¨
                        const imgContainer = document.createElement('div');
                        imgContainer.style.position = 'relative';
                        imgContainer.style.display = 'flex';
                        imgContainer.style.justifyContent = 'center';
                        imgContainer.style.alignItems = 'center';
                        imgContainer.style.background = 'transparent';
                        imgContainer.style.borderRadius = '4px';
                        imgContainer.style.overflow = 'hidden';
                        imgContainer.style.transition = 'all 0.3s ease';

                        // æ·»åŠ æ‚¬åœæ•ˆæœ - å¢å¼ºæ¡†é€‰æ•ˆæœï¼ˆçº¢è‰²ç³»ï¼Œä»£è¡¨åˆ é™¤è­¦å‘Šï¼‰
                        imgContainer.addEventListener('mouseenter', function() {
                            this.style.opacity = '1';
                            this.style.boxShadow = '0 0 15px rgba(220, 53, 69, 0.7)';
                            this.style.transform = 'scale(1)';
                            // æ·»åŠ é€‰ä¸­æ»¤é•œæ•ˆæœ
                            const canvas = this.querySelector('canvas');
                            if (canvas) {
                                canvas.style.filter = 'brightness(1.1) contrast(1.1) sepia(0.3)';
                            }
                        });

                        imgContainer.addEventListener('mouseleave', function() {
                            this.style.opacity = '1';
                            this.style.boxShadow = 'none';
                            this.style.transform = 'scale(1)';
                            // ç§»é™¤é€‰ä¸­æ»¤é•œæ•ˆæœ
                            const canvas = this.querySelector('canvas');
                            if (canvas) {
                                canvas.style.filter = 'none';
                            }
                        });

                        // æ·»åŠ å•å‡»åˆ é™¤äº‹ä»¶ï¼ˆåªæœ‰åœ¨æ²¡æœ‰æ‹–æ‹½çš„æƒ…å†µä¸‹æ‰è§¦å‘ï¼‰
                        let isDragStarted = false;
                        let clickStartX = 0;
                        let clickStartY = 0;

                        imgContainer.addEventListener('mousedown', function(e) {
                            // è®°å½•ç‚¹å‡»èµ·å§‹ä½ç½®
                            clickStartX = e.clientX;
                            clickStartY = e.clientY;
                            isDragStarted = false;
                        });

                        imgContainer.addEventListener('mousemove', function(e) {
                            // å¦‚æœç§»åŠ¨è·ç¦»è¶…è¿‡é˜ˆå€¼ï¼Œè®¤ä¸ºæ˜¯æ‹–æ‹½
                            if (Math.abs(e.clientX - clickStartX) > 5 || Math.abs(e.clientY - clickStartY) > 5) {
                                isDragStarted = true;
                            }
                        });

                        imgContainer.addEventListener('click', function(e) {
                            // åªæœ‰åœ¨æ²¡æœ‰æ‹–æ‹½çš„æƒ…å†µä¸‹æ‰è§¦å‘åˆ é™¤
                            if (!isDragStarted) {
                                e.stopPropagation();
                                deleteImage(cardIndex, index);
                            }
                        });

                        // åˆ›å»ºcanvaså…ƒç´ æ¥æ˜¾ç¤ºåŸå›¾
                        const canvas = document.createElement('canvas');
                        canvas.style.transition = 'all 0.3s ease';

                        // åŠ è½½å›¾ç‰‡å¹¶ç»˜åˆ¶
                        const img = new Image();
                        img.onload = function() {
                            // è®¡ç®—åŸå§‹å®½é«˜æ¯”
                            const aspectRatio = img.width / img.height;

                            // æ ¹æ®é»˜è®¤ç¼©æ”¾é«˜åº¦è®¡ç®—canvaså°ºå¯¸ï¼Œä¿æŒåŸå›¾æ¯”ä¾‹
                            let canvasHeight = defaultScaleHeight;
                            let canvasWidth = canvasHeight * aspectRatio;

                            // è®¾ç½®canvaså°ºå¯¸
                            canvas.width = img.width;
                            canvas.height = img.height;

                            // è®¾ç½®canvasæ˜¾ç¤ºå°ºå¯¸
                            canvas.style.width = `${canvasWidth}px`;
                            canvas.style.height = `${canvasHeight}px`;

                            // è®¾ç½®å®¹å™¨å°ºå¯¸
                            imgContainer.style.width = `${canvasWidth}px`;
                            imgContainer.style.height = `${canvasHeight}px`;

                            const ctx = canvas.getContext('2d');

                            // æ¸…ç©ºcanvas
                            ctx.clearRect(0, 0, img.width, img.height);

                            // è®¾ç½®å›¾åƒå¹³æ»‘ç¦ç”¨ï¼Œä¿æŒåƒç´ æ¸…æ™°
                            ctx.imageSmoothingEnabled = true;
                            ctx.imageSmoothingQuality = 'medium';

                            // ç»˜åˆ¶åŸå§‹å¤§å°çš„å›¾åƒ
                            ctx.drawImage(img, 0, 0, img.width, img.height);

                            // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å›¾ç‰‡éƒ½å·²åŠ è½½å®Œæˆ
                            loadedImages++;
                            if (loadedImages === totalImages) {
                                // æ‰€æœ‰å›¾ç‰‡åŠ è½½å®Œæˆåï¼Œæ˜¾ç¤ºé¢„è§ˆå®¹å™¨
                                previewContainer.style.opacity = '1';
                                previewContainer.style.visibility = 'visible';
                                resolve();
                            }
                        };
                        img.onerror = function() {
                            // å³ä½¿å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œä¹Ÿè¦ç»§ç»­è®¡æ•°
                            loadedImages++;
                            if (loadedImages === totalImages) {
                                // æ‰€æœ‰å›¾ç‰‡åŠ è½½å®Œæˆåï¼Œæ˜¾ç¤ºé¢„è§ˆå®¹å™¨
                                previewContainer.style.opacity = '1';
                                previewContainer.style.visibility = 'visible';
                                resolve();
                            }
                        };
                        img.src = imageItem.previewUrl;

                        // ç»„è£…å›¾ç‰‡å®¹å™¨
                        imgContainer.appendChild(canvas);
                        previewContainer.appendChild(imgContainer);
                    } else {
                        loadedImages++;
                        if (loadedImages === totalImages) {
                            // æ‰€æœ‰å›¾ç‰‡åŠ è½½å®Œæˆåï¼Œæ˜¾ç¤ºé¢„è§ˆå®¹å™¨
                            previewContainer.style.opacity = '1';
                            previewContainer.style.visibility = 'visible';
                            resolve();
                        }
                    }
                });
            });
        }

        // æ›´æ–°å•å¼ å¡ç‰‡çš„è¾“å‡ºé¢„è§ˆ
        function updateOutputPreview(cardIndex) {
            return new Promise((resolve) => {
                const card = cards[cardIndex];
                const cardElement = document.querySelector(`[data-card-index="${cardIndex}"]`);
                const outputContainer = cardElement.querySelector('.output-preview-images');

                // æ¸…ç©ºç°æœ‰é¢„è§ˆ
                outputContainer.innerHTML = '';

                // æš‚æ—¶éšè—é¢„è§ˆå®¹å™¨ï¼Œé¿å…ç”¨æˆ·çœ‹åˆ°å›¾ç‰‡åŠ è½½è¿‡ç¨‹
                outputContainer.style.opacity = '0';
                outputContainer.style.visibility = 'hidden';

                // è·å–é¢„è§ˆå®¹å™¨çš„é«˜åº¦ï¼Œè®¡ç®—é»˜è®¤ç¼©æ”¾æ¯”ä¾‹ï¼ˆä¸åŸå›¾é¢„è§ˆä¸€è‡´ï¼‰
                const containerElement = cardElement.querySelector('.preview-canvas-container');
                const containerHeight = containerElement.clientHeight;
                const defaultScaleHeight = containerHeight * 0.5;

                if (card.images.length === 0) {
                    // å¦‚æœæ²¡æœ‰å›¾ç‰‡ï¼Œæ˜¾ç¤ºç©ºå®¹å™¨
                    outputContainer.style.opacity = '1';
                    outputContainer.style.visibility = 'visible';
                    resolve();
                    return;
                }

                let loadedImages = 0;
                const totalImages = card.images.length;

                card.images.forEach((imageItem, index) => {
                    if (imageItem.previewUrl) {
                        // åˆ›å»ºcanvaså®¹å™¨
                        const canvasContainer = document.createElement('div');
                        canvasContainer.style.position = 'relative';
                        canvasContainer.style.display = 'flex';
                        canvasContainer.style.justifyContent = 'center';
                        canvasContainer.style.alignItems = 'center';
                        canvasContainer.style.background = 'transparent';
                        canvasContainer.style.borderRadius = '4px';
                        canvasContainer.style.overflow = 'hidden';
                        canvasContainer.style.transition = 'all 0.3s ease';

                        // æ·»åŠ æ‚¬åœæ•ˆæœ - å¢å¼ºæ¡†é€‰æ•ˆæœï¼ˆçº¢è‰²ç³»ï¼Œä»£è¡¨åˆ é™¤è­¦å‘Šï¼‰
                        canvasContainer.addEventListener('mouseenter', function() {
                            this.style.opacity = '1';
                            this.style.boxShadow = '0 0 15px rgba(220, 53, 69, 0.7)';
                            this.style.transform = 'scale(1)';
                            // æ·»åŠ é€‰ä¸­æ»¤é•œæ•ˆæœ
                            const canvas = this.querySelector('canvas');
                            if (canvas) {
                                canvas.style.filter = 'brightness(1.1) contrast(1.1) sepia(0.3)';
                            }
                        });

                        canvasContainer.addEventListener('mouseleave', function() {
                            this.style.opacity = '1';
                            this.style.boxShadow = 'none';
                            this.style.transform = 'scale(1)';
                            // ç§»é™¤é€‰ä¸­æ»¤é•œæ•ˆæœ
                            const canvas = this.querySelector('canvas');
                            if (canvas) {
                                canvas.style.filter = 'none';
                            }
                        });

                        // æ·»åŠ å•å‡»åˆ é™¤äº‹ä»¶ï¼ˆåªæœ‰åœ¨æ²¡æœ‰æ‹–æ‹½çš„æƒ…å†µä¸‹æ‰è§¦å‘ï¼‰
                        let isDragStarted = false;
                        let clickStartX = 0;
                        let clickStartY = 0;

                        canvasContainer.addEventListener('mousedown', function(e) {
                            // è®°å½•ç‚¹å‡»èµ·å§‹ä½ç½®
                            clickStartX = e.clientX;
                            clickStartY = e.clientY;
                            isDragStarted = false;
                        });

                        canvasContainer.addEventListener('mousemove', function(e) {
                            // å¦‚æœç§»åŠ¨è·ç¦»è¶…è¿‡é˜ˆå€¼ï¼Œè®¤ä¸ºæ˜¯æ‹–æ‹½
                            if (Math.abs(e.clientX - clickStartX) > 5 || Math.abs(e.clientY - clickStartY) > 5) {
                                isDragStarted = true;
                            }
                        });

                        canvasContainer.addEventListener('click', function(e) {
                            // åªæœ‰åœ¨æ²¡æœ‰æ‹–æ‹½çš„æƒ…å†µä¸‹æ‰è§¦å‘åˆ é™¤
                            if (!isDragStarted) {
                                e.stopPropagation();
                                deleteImage(cardIndex, index);
                            }
                        });

                        // åˆ›å»ºcanvaså…ƒç´ 
                        const canvas = document.createElement('canvas');
                        canvas.style.transition = 'all 0.3s ease';

                        // åŠ è½½å›¾ç‰‡å¹¶å¤„ç†
                        const img = new Image();
                        img.onload = function() {
                            // è®¡ç®—åŸå§‹å®½é«˜æ¯”
                            const aspectRatio = img.width / img.height;

                            // æ ¹æ®é»˜è®¤ç¼©æ”¾é«˜åº¦è®¡ç®—canvaså°ºå¯¸ï¼Œä¿æŒåŸå›¾æ¯”ä¾‹
                            let canvasHeight = defaultScaleHeight;
                            let canvasWidth = canvasHeight * aspectRatio;

                            // è®¾ç½®canvaså°ºå¯¸
                            canvas.width = img.width;
                            canvas.height = img.height;

                            // è®¾ç½®canvasæ˜¾ç¤ºå°ºå¯¸
                            canvas.style.width = `${canvasWidth}px`;
                            canvas.style.height = `${canvasHeight}px`;

                            // è®¾ç½®å®¹å™¨å°ºå¯¸
                            canvasContainer.style.width = `${canvasWidth}px`;
                            canvasContainer.style.height = `${canvasHeight}px`;

                            const ctx = canvas.getContext('2d');

                            // ç»˜åˆ¶åŸå§‹å›¾ç‰‡åˆ°ä¸´æ—¶canvas
                            const tempCanvas = document.createElement('canvas');
                            tempCanvas.width = card.width;
                            tempCanvas.height = card.height;
                            const tempCtx = tempCanvas.getContext('2d');
                            tempCtx.drawImage(img, 0, 0, card.width, card.height);

                            // è·å–åŸå§‹åƒç´ æ•°æ®
                            let imageData = tempCtx.getImageData(0, 0, card.width, card.height);
                            imageData = processImageData(imageData, document.getElementById('colorFormat').value);

                            // å°†å¤„ç†åçš„æ•°æ®ç»˜åˆ¶åˆ°ä¸´æ—¶canvas
                            tempCtx.putImageData(imageData, 0, 0);

                            // æ¸…ç©ºè¾“å‡ºé¢„è§ˆcanvas
                            ctx.clearRect(0, 0, img.width, img.height);

                            // è®¾ç½®å›¾åƒå¹³æ»‘ç¦ç”¨ï¼Œä¿æŒåƒç´ æ¸…æ™°
                            ctx.imageSmoothingEnabled = true;
                            ctx.imageSmoothingQuality = 'medium';

                            // ç»˜åˆ¶å¤„ç†åçš„å›¾åƒ
                            ctx.drawImage(tempCanvas, 0, 0, card.width, card.height, 0, 0, img.width, img.height);

                            // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å›¾ç‰‡éƒ½å·²åŠ è½½å®Œæˆ
                            loadedImages++;
                            if (loadedImages === totalImages) {
                                // æ‰€æœ‰å›¾ç‰‡åŠ è½½å®Œæˆåï¼Œæ˜¾ç¤ºé¢„è§ˆå®¹å™¨
                                outputContainer.style.opacity = '1';
                                outputContainer.style.visibility = 'visible';
                                resolve();
                            }
                        };
                        img.onerror = function() {
                            // å³ä½¿å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œä¹Ÿè¦ç»§ç»­è®¡æ•°
                            loadedImages++;
                            if (loadedImages === totalImages) {
                                // æ‰€æœ‰å›¾ç‰‡åŠ è½½å®Œæˆåï¼Œæ˜¾ç¤ºé¢„è§ˆå®¹å™¨
                                outputContainer.style.opacity = '1';
                                outputContainer.style.visibility = 'visible';
                                resolve();
                            }
                        };
                        img.src = imageItem.previewUrl;

                        // ç»„è£…canvaså®¹å™¨
                        canvasContainer.appendChild(canvas);
                        outputContainer.appendChild(canvasContainer);
                    } else {
                        loadedImages++;
                        if (loadedImages === totalImages) {
                            // æ‰€æœ‰å›¾ç‰‡åŠ è½½å®Œæˆåï¼Œæ˜¾ç¤ºé¢„è§ˆå®¹å™¨
                            outputContainer.style.opacity = '1';
                            outputContainer.style.visibility = 'visible';
                            resolve();
                        }
                    }
                });
            });
        }





        // åˆå§‹åŒ–å¡ç‰‡äº‹ä»¶
        function initCard(cardIndex) {
            const card = document.querySelector(`[data-card-index="${cardIndex}"]`);

            // åˆå§‹åŒ–æ—¶å°†é¢„è§ˆçª—å£é«˜åº¦è®¾ç½®ä¸º75px
            adjustPreviewHeight(cardIndex, false);

            // åˆå§‹åŒ–é¢„è§ˆ
            updateOriginalPreviews(cardIndex);
            updateOutputPreview(cardIndex);

            // ä¸ºæ–°åˆ›å»ºçš„é¢„è§ˆå®¹å™¨æ·»åŠ æ»šè½®äº‹ä»¶ç›‘å¬å™¨
            setTimeout(() => {
                const cardElement = document.querySelector(`[data-card-index="${cardIndex}"]`);
                cardElement.querySelectorAll('.preview-canvas-container').forEach(function(container) {
                    addWheelListener(container);
                });
            }, 0);

            // ä¸ºå±…ä¸­ç”»å¸ƒæŒ‰é’®æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
            const centerCanvasBtns = card.querySelectorAll('.center-canvas-btn');
            centerCanvasBtns.forEach(function(btn) {
                btn.addEventListener('click', function() {
                    const currentIndex = parseInt(this.closest('.image-card').getAttribute('data-card-index'));
                    centerCanvas(currentIndex);
                });
            });

            // å›¾ç‰‡é€‰æ‹©äº‹ä»¶ - åŠ¨æ€è·å–å½“å‰ç´¢å¼•
            const fileInput = card.querySelector('.image-file-input');
            fileInput.addEventListener('change', function(e) {
                const currentIndex = parseInt(this.closest('.image-card').getAttribute('data-card-index'));
                const card = cards[currentIndex];
                const maxImages = 1024;

                // è®¡ç®—å‰©ä½™å¯æ·»åŠ çš„å›¾ç‰‡æ•°é‡
                const remainingSlots = maxImages - card.images.length;

                // å¦‚æœå‰©ä½™æ•°é‡ä¸è¶³ï¼Œåªå¤„ç†éƒ¨åˆ†æ–‡ä»¶
                if (e.target.files.length > remainingSlots) {
                    alert(`æ¯ä¸ªé€‰é¡¹å¡æœ€å¤šåªèƒ½æ·»åŠ ${maxImages}å¼ å›¾ç‰‡ï¼Œå½“å‰è¿˜å¯æ·»åŠ ${remainingSlots}å¼ ï¼`);
                    return;
                }

                // æ‰¹é‡å¤„ç†é€‰ä¸­çš„æ–‡ä»¶
                const filesToProcess = Array.from(e.target.files);
                batchHandleImageSelect(currentIndex, filesToProcess);

                // é‡ç½®inputå€¼ï¼Œå…è®¸å†æ¬¡é€‰æ‹©åŒä¸€æ–‡ä»¶
                this.value = '';
            });

            // å®½åº¦è¾“å…¥å˜åŒ– - åŠ¨æ€è·å–å½“å‰ç´¢å¼•
            const widthInput = card.querySelector('.width-input');
            widthInput.addEventListener('input', function(e) {
                const currentIndex = parseInt(this.closest('.image-card').getAttribute('data-card-index'));
                handleWidthChange(currentIndex, parseInt(e.target.value) || 1);
            });

            // é«˜åº¦è¾“å…¥å˜åŒ– - åŠ¨æ€è·å–å½“å‰ç´¢å¼•
            const heightInput = card.querySelector('.height-input');
            heightInput.addEventListener('input', function(e) {
                const currentIndex = parseInt(this.closest('.image-card').getAttribute('data-card-index'));
                handleHeightChange(currentIndex, parseInt(e.target.value) || 1);
            });

            // é”å®šæ¯”ä¾‹å˜åŒ– - åŠ¨æ€è·å–å½“å‰ç´¢å¼•
            const lockAspect = card.querySelector('.lock-aspect');
            lockAspect.addEventListener('change', function(e) {
                const currentIndex = parseInt(this.closest('.image-card').getAttribute('data-card-index'));
                handleAspectLockChange(currentIndex, e.target.checked);
            });

            // æ•°ç»„åå‰ç¼€å˜åŒ– - åŠ¨æ€è·å–å½“å‰ç´¢å¼•
            const arrayPrefixInput = card.querySelector('.array-prefix-input');
            arrayPrefixInput.addEventListener('input', function(e) {
                const currentIndex = parseInt(this.closest('.image-card').getAttribute('data-card-index'));
                handleArrayPrefixChange(currentIndex, e.target.value);
            });

            // åˆ é™¤å¡ç‰‡äº‹ä»¶ - åŠ¨æ€è·å–å½“å‰ç´¢å¼•
            const deleteBtn = card.querySelector('.delete-card-btn');
            deleteBtn.addEventListener('click', function() {
                const currentIndex = parseInt(this.closest('.image-card').getAttribute('data-card-index'));
                deleteCard(currentIndex);
            });

            // åˆ é™¤æ‰€æœ‰å›¾ç‰‡äº‹ä»¶ - åŠ¨æ€è·å–å½“å‰ç´¢å¼•
            const deleteAllBtns = card.querySelectorAll('.delete-all-btn');
            deleteAllBtns.forEach(function(btn) {
                btn.addEventListener('click', function() {
                    const currentIndex = parseInt(this.closest('.image-card').getAttribute('data-card-index'));
                    deleteAllImages(currentIndex);
                });
            });
        }

        // æ·»åŠ æ–°å¡ç‰‡
        function addCard() {
            const cardsContainer = document.getElementById('cardsContainer');
            const cardCount = cardsContainer.children.length;
            const newCardIndex = cardCount;

            // åˆ›å»ºæ–°å¡ç‰‡
            const newCard = document.createElement('div');
            newCard.className = 'image-card section';
            newCard.setAttribute('data-card-index', newCardIndex);

            // è®¾ç½®å¡ç‰‡å†…å®¹
            newCard.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3>å›¾ç‰‡ ${newCardIndex + 1}</h3>
                    <button class="delete-card-btn" title="åˆ é™¤å›¾ç‰‡">ğŸ—‘ï¸</button>
                </div>

                <!-- å›¾ç‰‡é€‰æ‹© -->
                <div class="file-input-container">
                    <input type="file" class="image-file-input file-input" accept="image/jpg,image/jpeg,image/png,image/bmp" multiple>
                    <label class="file-input-label">
                        <i>ğŸ“</i>
                        <div>ç‚¹å‡»æˆ–æ‹–æ‹½å›¾ç‰‡åˆ°æ­¤å¤„</div>
                        <div style="font-size: 0.8em; color: #999; margin-top: 5px;">æ”¯æŒæ ¼å¼ï¼šJPGã€JPEGã€PNGã€BMP</div>
                        <div style="font-size: 0.8em; color: #999; margin-top: 5px;">å·²æ·»åŠ  <span class="image-count">0</span>/1024 å¼ å›¾ç‰‡</div>
                    </label>
                </div>

                <!-- åŸå›¾é¢„è§ˆ -->
                <div style="margin-top: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                        <h4 style="color: #666; margin: 0;">åŸå›¾é¢„è§ˆ</h4>
                        <div style="display: flex; gap: 5px;">
                            <button class="center-canvas-btn" style="background: rgba(79, 172, 254, 0.8); color: white; border: none; border-radius: 4px; padding: 2px 8px; font-size: 10px; cursor: pointer; transition: all 0.3s ease;">å±…ä¸­ç”»å¸ƒ</button>
                            <button class="delete-all-btn" style="background: rgba(220, 53, 69, 0.8); color: white; border: none; border-radius: 4px; padding: 2px 8px; font-size: 10px; cursor: pointer; transition: all 0.3s ease;">åˆ é™¤æ‰€æœ‰</button>
                        </div>
                    </div>
                    <div style="position: relative; border-radius: 8px; overflow: hidden; height: 150px;" class="chessboard-bg">
                        <div class="preview-canvas-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden;">
                            <div class="preview-images" style="position: absolute; top: 0; left: 0; display: grid; grid-template-columns: repeat(9, auto); gap: 8px; padding: 10px; transform-origin: center; transition: transform 0.1s ease;"></div>
                        </div>
                    </div>
                </div>
                <!-- è¾“å‡ºé¢„è§ˆ -->
                <div style="margin-top: 15px;">
                    <h4 style="margin-bottom: 5px; color: #666;">è¾“å‡ºé¢„è§ˆ</h4>
                    <div style="position: relative; border-radius: 8px; overflow: hidden; height: 150px;" class="chessboard-bg">
                        <div class="preview-canvas-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden;">
                            <div class="output-preview-images" style="position: absolute; top: 0; left: 0; display: grid; grid-template-columns: repeat(9, auto); gap: 8px; padding: 10px; transform-origin: center; transition: transform 0.1s ease;"></div>
                        </div>
                    </div>
                </div>

                <!-- å°ºå¯¸è°ƒæ•´ -->
                <div style="margin-top: 15px;">
                    <h4 style="margin-bottom: 10px; color: #666;">å°ºå¯¸è°ƒæ•´</h4>
                    <div class="size-controls">
                        <div class="size-input-group">
                            <label>å®½åº¦ (px)</label>
                            <input type="number" class="width-input" min="1" step="1" disabled>
                        </div>
                        <div class="size-input-group">
                            <label>é«˜åº¦ (px)</label>
                            <input type="number" class="height-input" min="1" step="1" disabled>
                        </div>
                        <div class="aspect-lock" style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" class="lock-aspect" checked style="width: 18px; height: 18px; margin: 0; cursor: pointer;">
                            <span>é”å®šæ¯”ä¾‹</span>
                        </div>
                    </div>
                </div>

                <!-- æ•°ç»„åå‰ç¼€ -->
                <div style="margin-top: 15px;">
                    <h4 style="margin-bottom: 10px; color: #666;">æ•°ç»„åå‰ç¼€</h4>
                    <div class="filename-input-group">
                        <input type="text" class="array-prefix-input" placeholder="è¯·è¾“å…¥æ•°ç»„åå‰ç¼€">
                    </div>
                </div>

                <!-- è¾“å‡ºè¯¦æƒ… -->
                <div style="margin-top: 15px;">
                    <h4 style="margin-bottom: 10px; color: #666;">è¾“å‡ºè¯¦æƒ…</h4>
                    <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; font-size: 0.9em;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <span style="color: #666;">åŸå›¾æ•°æ®å¤§å°ï¼š</span>
                            <span class="original-size" style="font-weight: bold;">0 B</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <span style="color: #666;">è¾“å‡ºå›¾ç‰‡æ•°æ®å¤§å°ï¼š</span>
                            <span class="output-size" style="font-weight: bold;">0 B</span>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <span style="color: #666;">å‹ç¼©ç‡ï¼š</span>
                            <span class="compression-ratio" style="font-weight: bold;">0%</span>
                        </div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px; margin-top: 15px;">
                        <input type="checkbox" class="combine-as-array" checked style="width: 18px; height: 18px; margin: 0; cursor: pointer;">
                        <span>ç»„åˆä¸ºæ•°ç»„</span>
                    </div>
                </div>

                <!-- å¡ç‰‡çŠ¶æ€ -->
                <div class="card-status" style="margin-top: 10px; font-size: 0.8em; color: #999; text-align: right;"></div>
            `;

            // æ·»åŠ åˆ°å®¹å™¨
            cardsContainer.appendChild(newCard);

            // åˆ›å»ºå¡ç‰‡æ•°æ®å¯¹è±¡
            const newCardData = new ImageCard(newCardIndex);
            cards.push(newCardData);

            // åˆå§‹åŒ–å¡ç‰‡äº‹ä»¶
            initCard(newCardIndex);

            // è®¾ç½®é»˜è®¤æ•°ç»„åå‰ç¼€ï¼Œç¡®ä¿å”¯ä¸€
            const defaultPrefix = generateUniquePrefix(newCardIndex);
            updateArrayPrefix(newCardIndex, defaultPrefix);

            // æ›´æ–°åˆ é™¤æŒ‰é’®çŠ¶æ€
            updateDeleteButtons();

            // æ›´æ–°å¡ç‰‡æ•°é‡æ˜¾ç¤º
            updateCardCountDisplay();
        }

        // åˆ é™¤å¡ç‰‡
        function deleteCard(cardIndex) {
            const cardsContainer = document.getElementById('cardsContainer');
            const cardCount = cardsContainer.children.length;

            // ä¸èƒ½åˆ é™¤æœ€åä¸€å¼ å¡ç‰‡
            if (cardCount <= 1) {
                alert('ä¸èƒ½åˆ é™¤æœ€åä¸€å¼ å¡ç‰‡ï¼');
                return;
            }

            // ç§»é™¤å¡ç‰‡å…ƒç´ 
            const cardToDelete = document.querySelector(`[data-card-index="${cardIndex}"]`);
            cardsContainer.removeChild(cardToDelete);

            // ç§»é™¤å¡ç‰‡æ•°æ®
            cards.splice(cardIndex, 1);

            // æ›´æ–°å‰©ä½™å¡ç‰‡çš„ç´¢å¼•å’Œæ˜¾ç¤º
            updateCardIndices();

            // æ›´æ–°åˆ é™¤æŒ‰é’®çŠ¶æ€
            updateDeleteButtons();

            // æ£€æŸ¥æ˜¯å¦å¯ä»¥è½¬æ¢
            checkConvertButtonState();

            // æ›´æ–°å¡ç‰‡æ•°é‡æ˜¾ç¤º
            updateCardCountDisplay();
        }

        // æ›´æ–°å¡ç‰‡æ•°é‡æ˜¾ç¤º
        function updateCardCountDisplay() {
            const cardCount = cards.length;
            const cardCountElement = document.getElementById('cardCount');
            cardCountElement.textContent = `(${cardCount}ä¸ªå›¾ç‰‡é€‰é¡¹å¡)`;
        }

        // æ›´æ–°å·²æ·»åŠ å›¾ç‰‡æ•°é‡æ˜¾ç¤º
        function updateImageCountDisplay(cardIndex) {
            const card = cards[cardIndex];
            const cardElement = document.querySelector(`[data-card-index="${cardIndex}"]`);
            const countElement = cardElement.querySelector('.image-count');
            if (countElement) {
                countElement.textContent = card.images.length;
            }
        }

        // æ›´æ–°å¡ç‰‡ç´¢å¼•
        function updateCardIndices() {
            const cardsContainer = document.getElementById('cardsContainer');
            const cardElements = cardsContainer.children;

            for (let i = 0; i < cardElements.length; i++) {
                const cardElement = cardElements[i];
                const cardData = cards[i];

                // æ›´æ–°å…ƒç´ ç´¢å¼•
                cardElement.setAttribute('data-card-index', i);

                // æ›´æ–°æ ‡é¢˜
                const title = cardElement.querySelector('h3');
                title.textContent = `å›¾ç‰‡ ${i + 1}`;

                // æ›´æ–°å¡ç‰‡æ•°æ®ç´¢å¼•
                cardData.index = i;

                // æ£€æŸ¥å¹¶æ›´æ–°æ•°ç»„åå‰ç¼€ï¼Œç¡®ä¿å”¯ä¸€æ€§
                const prefix = cardData.arrayPrefix;
                const expectedPrefix = `pic${i + 1}`;

                // åªæœ‰å½“å‰ç¼€æ˜¯é»˜è®¤æ ¼å¼ï¼ˆpicXï¼‰ä¸”ä¸å½“å‰ç´¢å¼•ä¸åŒ¹é…æ—¶ï¼Œæ‰éœ€è¦æ›´æ–°
                if (prefix === `pic${i + 2}` || (prefix.startsWith('pic') && !isNaN(prefix.slice(3)) && parseInt(prefix.slice(3)) !== i + 1)) {
                    // æ£€æŸ¥æ˜¯å¦ä¸å…¶ä»–å‰ç¼€å†²çª
                    if (checkPrefixConflict(expectedPrefix, i)) {
                        // å¦‚æœå†²çªï¼Œç”Ÿæˆå”¯ä¸€å‰ç¼€
                        const newPrefix = generateUniquePrefix(i);
                        updateArrayPrefix(i, newPrefix);
                    } else {
                        // å¦‚æœä¸å†²çªï¼Œä½¿ç”¨é¢„æœŸå‰ç¼€
                        updateArrayPrefix(i, expectedPrefix);
                    }
                }
            }

            // æ›´æ–°å¡ç‰‡æ•°é‡æ˜¾ç¤º
            updateCardCountDisplay();
        }

        // æ›´æ–°åˆ é™¤æŒ‰é’®çŠ¶æ€
        function updateDeleteButtons() {
            const cardsContainer = document.getElementById('cardsContainer');
            const cardCount = cardsContainer.children.length;
            const deleteButtons = cardsContainer.querySelectorAll('.delete-card-btn');

            deleteButtons.forEach((btn, index) => {
                btn.disabled = (cardCount <= 1);
                if (cardCount <= 1) {
                    btn.style.opacity = '0.5';
                    btn.style.cursor = 'not-allowed';
                } else {
                    btn.style.opacity = '1';
                    btn.style.cursor = 'pointer';
                }
            });
        }

        // å¤„ç†å›¾ç‰‡é€‰æ‹©
        // æ‰¹é‡å¤„ç†å›¾ç‰‡é€‰æ‹©
        function batchHandleImageSelect(cardIndex, files) {
            if (!files || files.length === 0) return;

            const card = cards[cardIndex];
            const maxImages = 1024;
            const originalImageCount = card.images.length;

            // è¿‡æ»¤æ‰å·²å­˜åœ¨çš„å›¾ç‰‡
            const newFiles = files.filter(file => {
                // æ£€æŸ¥å›¾ç‰‡æ˜¯å¦å·²å­˜åœ¨ï¼ˆé€šè¿‡æ–‡ä»¶åå’Œå¤§å°åˆ¤æ–­ï¼‰
                const existingImage = card.images.find(image =>
                    image.file &&
                    image.file.name === file.name &&
                    image.file.size === file.size
                );
                return !existingImage;
            });

            if (newFiles.length === 0) {
                return; // æ²¡æœ‰æ–°å›¾ç‰‡éœ€è¦æ·»åŠ 
            }

            // åˆ›å»ºå¤„ç†é˜Ÿåˆ—
            const processPromises = [];

            // ç¬¬ä¸€å¼ å›¾ç‰‡ç”¨äºç¡®å®šå°ºå¯¸
            let referenceWidth = card.originalWidth;
            let referenceHeight = card.originalHeight;
            let hasReferenceSize = card.images.length > 0;

            // æ‰¹é‡è¯»å–å›¾ç‰‡æ•°æ®
            for (const file of newFiles) {
                const processPromise = new Promise((resolve, reject) => {
                    // é¢„è§ˆå›¾ç‰‡
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const previewUrl = e.target.result;

                        // åˆ›å»ºä¸´æ—¶å›¾ç‰‡å¯¹è±¡è·å–å°ºå¯¸
                        const tempImg = new Image();
                        tempImg.onload = function() {
                            const imgWidth = tempImg.naturalWidth;
                            const imgHeight = tempImg.naturalHeight;

                            // éªŒè¯å°ºå¯¸ä¸€è‡´æ€§
                            if (hasReferenceSize) {
                                if (imgWidth !== referenceWidth || imgHeight !== referenceHeight) {
                                    reject(new Error('ä¸å…è®¸æ·»åŠ ä¸åŒå°ºå¯¸å›¾ç‰‡åˆ°å›¾ç‰‡ç»„'));
                                    return;
                                }
                            } else {
                                // ç¬¬ä¸€å¼ å›¾ç‰‡ï¼Œè®¾ç½®å‚è€ƒå°ºå¯¸
                                referenceWidth = imgWidth;
                                referenceHeight = imgHeight;
                                hasReferenceSize = true;
                            }

                            // è¿”å›å¤„ç†å¥½çš„å›¾ç‰‡æ•°æ®
                            resolve({
                                file: file,
                                previewUrl: previewUrl,
                                width: imgWidth,
                                height: imgHeight
                            });
                        };
                        tempImg.onerror = () => reject(new Error('å›¾ç‰‡åŠ è½½å¤±è´¥'));
                        tempImg.src = previewUrl;
                    };
                    reader.onerror = () => reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥'));
                    reader.readAsDataURL(file);
                });

                processPromises.push(processPromise);
            }

            // æ‰§è¡Œæ‰¹é‡å¤„ç†
            Promise.all(processPromises)
                .then(async processedImages => {
                    // æ‰¹é‡æ·»åŠ å›¾ç‰‡åˆ°å¡ç‰‡
                    for (const processedImage of processedImages) {
                        // åˆ›å»ºæ–°çš„å›¾ç‰‡é¡¹
                        const imageItem = new ImageItem();
                        imageItem.file = processedImage.file;
                        imageItem.previewUrl = processedImage.previewUrl;
                        imageItem.isValid = true;

                        // æ·»åŠ åˆ°å¡ç‰‡çš„å›¾ç‰‡æ•°ç»„
                        card.images.push(imageItem);
                    }

                    // æ›´æ–°å¡ç‰‡çŠ¶æ€
                    card.isValid = card.images.length > 0;

                    // åˆå§‹åŒ–å¡ç‰‡å°ºå¯¸ï¼ˆå¦‚æœæ˜¯é¦–æ¬¡æ·»åŠ å›¾ç‰‡ï¼‰
                    if (card.images.length === processedImages.length) {
                        card.originalWidth = referenceWidth;
                        card.originalHeight = referenceHeight;
                        card.aspectRatio = referenceWidth / referenceHeight;
                        card.width = referenceWidth;
                        card.height = referenceHeight;

                        // æ›´æ–°UIå°ºå¯¸è¾“å…¥æ¡†
                        const cardElement = document.querySelector(`[data-card-index="${cardIndex}"]`);
                        if (cardElement) {
                            const widthInput = cardElement.querySelector('.width-input');
                            const heightInput = cardElement.querySelector('.height-input');
                            widthInput.value = card.width;
                            heightInput.value = card.height;
                            widthInput.disabled = false;
                            heightInput.disabled = false;
                        }
                    }

                    // æ‰¹é‡æ›´æ–°UIï¼Œåªæ›´æ–°ä¸€æ¬¡
                    const cardElement = document.querySelector(`[data-card-index="${cardIndex}"]`);
                    if (cardElement) {
                        // æ›´æ–°å·²æ·»åŠ å›¾ç‰‡æ•°é‡æ˜¾ç¤º
                        updateImageCountDisplay(cardIndex);

                        // æ¢å¤é¢„è§ˆçª—å£å¤§å°
                        adjustPreviewHeight(cardIndex, true);

                        // æ›´æ–°åŸå›¾é¢„è§ˆå¹¶ç­‰å¾…æ‰€æœ‰å›¾ç‰‡åŠ è½½å®Œæˆ
                        await updateOriginalPreviews(cardIndex);

                        // æ›´æ–°è¾“å‡ºé¢„è§ˆå¹¶ç­‰å¾…æ‰€æœ‰å›¾ç‰‡åŠ è½½å®Œæˆ
                        await updateOutputPreview(cardIndex);

                        // æ›´æ–°å¡ç‰‡çŠ¶æ€
                        updateCardStatus(cardIndex, `âœ… å·²æ·»åŠ  ${card.images.length} å¼ å›¾ç‰‡`);

                        // æ›´æ–°è¾“å‡ºè¯¦æƒ…
                        updateOutputDetails(cardIndex);

                        // æ‰€æœ‰å›¾ç‰‡åŠ è½½å®Œæˆåæ‰§è¡Œå±…ä¸­ç”»å¸ƒ
                        centerCanvas(cardIndex);

                        // æ£€æŸ¥æ˜¯å¦å¯ä»¥è½¬æ¢
                        checkConvertButtonState();
                    }
                })
                .catch(error => {
                    alert(error.message);
                });
        }

        function handleImageSelect(cardIndex, file) {
            // è°ƒç”¨æ‰¹é‡å¤„ç†å‡½æ•°ï¼Œä¼ å…¥åŒ…å«å•ä¸ªæ–‡ä»¶çš„æ•°ç»„
            batchHandleImageSelect(cardIndex, [file]);
        }

        // å¤„ç†å®½åº¦å˜åŒ–
        function handleWidthChange(cardIndex, newWidth) {
            const card = cards[cardIndex];
            const cardElement = document.querySelector(`[data-card-index="${cardIndex}"]`);
            const lockAspect = cardElement.querySelector('.lock-aspect').checked;

            // é™åˆ¶æœ€å°å®½åº¦
            newWidth = Math.max(1, Math.min(newWidth, card.originalWidth));
            card.width = newWidth;

            // å¦‚æœé”å®šæ¯”ä¾‹ï¼Œæ›´æ–°é«˜åº¦
            if (lockAspect) {
                const newHeight = Math.round(newWidth / card.aspectRatio);
                card.height = Math.max(1, Math.min(newHeight, card.originalHeight));

                // æ›´æ–°é«˜åº¦è¾“å…¥æ¡†
                const heightInput = cardElement.querySelector('.height-input');
                heightInput.value = card.height;
            }

            // æ›´æ–°å®½åº¦è¾“å…¥æ¡†
            const widthInput = cardElement.querySelector('.width-input');
            widthInput.value = newWidth;

            // æ›´æ–°è¾“å‡ºé¢„è§ˆå’Œè¾“å‡ºè¯¦æƒ…
            updateOutputPreview(cardIndex);
            updateOutputDetails(cardIndex);

            // é‡æ–°æ£€æŸ¥æŒ‰é’®çŠ¶æ€
            checkConvertButtonState();
        }

        // å¤„ç†é«˜åº¦å˜åŒ–
        function handleHeightChange(cardIndex, newHeight) {
            const card = cards[cardIndex];
            const cardElement = document.querySelector(`[data-card-index="${cardIndex}"]`);
            const lockAspect = cardElement.querySelector('.lock-aspect').checked;

            // é™åˆ¶æœ€å°é«˜åº¦
            newHeight = Math.max(1, Math.min(newHeight, card.originalHeight));
            card.height = newHeight;

            // å¦‚æœé”å®šæ¯”ä¾‹ï¼Œæ›´æ–°å®½åº¦
            if (lockAspect) {
                const newWidth = Math.round(newHeight * card.aspectRatio);
                card.width = Math.max(1, Math.min(newWidth, card.originalWidth));

                // æ›´æ–°å®½åº¦è¾“å…¥æ¡†
                const widthInput = cardElement.querySelector('.width-input');
                widthInput.value = card.width;
            }

            // æ›´æ–°é«˜åº¦è¾“å…¥æ¡†
            const heightInput = cardElement.querySelector('.height-input');
            heightInput.value = newHeight;

            // æ›´æ–°è¾“å‡ºé¢„è§ˆå’Œè¾“å‡ºè¯¦æƒ…
            updateOutputPreview(cardIndex);
            updateOutputDetails(cardIndex);

            // é‡æ–°æ£€æŸ¥æŒ‰é’®çŠ¶æ€
            checkConvertButtonState();
        }

        // å¤„ç†é”å®šæ¯”ä¾‹å˜åŒ–
        function handleAspectLockChange(cardIndex, isLocked) {
            const card = cards[cardIndex];
            if (isLocked) {
                // é‡æ–°è®¡ç®—å°ºå¯¸ï¼Œä¿æŒæ¯”ä¾‹
                const newHeight = Math.round(card.width / card.aspectRatio);
                card.height = Math.max(1, Math.min(newHeight, card.originalHeight));

                const cardElement = document.querySelector(`[data-card-index="${cardIndex}"]`);
                const heightInput = cardElement.querySelector('.height-input');
                heightInput.value = card.height;
            }
        }

        // æ£€æŸ¥å‰ç¼€æ˜¯å¦å†²çª
        function checkPrefixConflict(prefix, excludeIndex = -1) {
            for (let i = 0; i < cards.length; i++) {
                if (i === excludeIndex) continue;
                if (cards[i].arrayPrefix === prefix) {
                    return true;
                }
            }
            return false;
        }

        // ç”Ÿæˆå”¯ä¸€å‰ç¼€
        function generateUniquePrefix(cardIndex) {
            let prefix = `pic${cardIndex + 1}`;
            let counter = 1;

            // å¦‚æœå‰ç¼€å·²å­˜åœ¨ï¼Œå°è¯•ä½¿ç”¨é€’å¢æ•°å­—ç”Ÿæˆæ–°å‰ç¼€
            while (checkPrefixConflict(prefix)) {
                prefix = `pic${cardIndex + 1}_${counter}`;
                counter++;
            }

            return prefix;
        }

        // å¤„ç†æ•°ç»„åå‰ç¼€å˜åŒ–
        function handleArrayPrefixChange(cardIndex, value) {
            // éªŒè¯å’Œè°ƒæ•´æ•°ç»„åå‰ç¼€
            let prefix = value;

            // ç§»é™¤æ‰€æœ‰éå­—æ¯æ•°å­—å’Œä¸‹åˆ’çº¿çš„å­—ç¬¦
            prefix = prefix.replace(/[^a-zA-Z0-9_]/g, '');

            // å¦‚æœä»¥æ•°å­—å¼€å¤´ï¼Œæ·»åŠ ä¸‹åˆ’çº¿
            if (/^\d/.test(prefix)) {
                prefix = '_' + prefix;
            }

            // å¦‚æœä¸ºç©ºï¼Œè®¾ç½®é»˜è®¤å€¼
            if (prefix === '') {
                prefix = generateUniquePrefix(cardIndex);
            } else {
                // æ£€æŸ¥å‰ç¼€æ˜¯å¦ä¸å…¶ä»–å¡ç‰‡å†²çª
                if (checkPrefixConflict(prefix, cardIndex)) {
                    // å¦‚æœå†²çªï¼Œä½¿ç”¨ç”Ÿæˆçš„å”¯ä¸€å‰ç¼€
                    prefix = generateUniquePrefix(cardIndex);
                }
            }

            // æ›´æ–°æ•°ç»„åå‰ç¼€
            updateArrayPrefix(cardIndex, prefix);
        }

        // æ›´æ–°æ•°ç»„åå‰ç¼€
        function updateArrayPrefix(cardIndex, prefix) {
            const card = cards[cardIndex];
            card.arrayPrefix = prefix;

            // æ›´æ–°è¾“å…¥æ¡†
            const cardElement = document.querySelector(`[data-card-index="${cardIndex}"]`);
            const arrayPrefixInput = cardElement.querySelector('.array-prefix-input');
            arrayPrefixInput.value = prefix;
        }

        // æ›´æ–°å¡ç‰‡çŠ¶æ€
        function updateCardStatus(cardIndex, status) {
            const cardElement = document.querySelector(`[data-card-index="${cardIndex}"]`);
            const statusElement = cardElement.querySelector('.card-status');
            statusElement.textContent = status;
        }

        // æ£€æŸ¥æ•°ç»„åå‰ç¼€æ˜¯å¦å”¯ä¸€
        function checkArrayPrefixUnique() {
            const prefixes = new Set();
            for (const card of cards) {
                if (prefixes.has(card.arrayPrefix)) {
                    return false;
                }
                prefixes.add(card.arrayPrefix);
            }
            return true;
        }

        // æ£€æŸ¥æ˜¯å¦å¯ä»¥è½¬æ¢å’Œé¢„è§ˆ
        function checkConvertButtonState() {
            const convertBtn = document.getElementById('convertBtn');
            const exportPreviewBtn = document.getElementById('exportPreviewBtn');

            // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å¡ç‰‡éƒ½æœ‰æœ‰æ•ˆå›¾ç‰‡
            const allValid = cards.every(card => card.isValid);

            // æ£€æŸ¥è¾“å‡ºå›¾ç‰‡æ•°æ®å¤§å°æ˜¯å¦å°äº2M
            let totalOutputSize = 0;
            if (allValid) {
                // è·å–å½“å‰å–æ¨¡è®¾ç½®
                const colorFormat = document.getElementById('colorFormat').value;
                const compressionAlgorithm = document.getElementById('compressionAlgorithm').value;

                // è®¡ç®—æ€»è¾“å‡ºå¤§å°
                for (const card of cards) {
                    // è®¡ç®—æ¯åƒç´ å­—èŠ‚æ•°
                    let bytesPerPixel = 3; // é»˜è®¤RGB888
                    if (colorFormat === 'rgb565') {
                        bytesPerPixel = 2;
                    } else if (colorFormat === 'rgb332') {
                        bytesPerPixel = 1;
                    } else if (colorFormat === 'argb8888') {
                        bytesPerPixel = 4;
                    } else if (colorFormat === 'argb4444') {
                        bytesPerPixel = 2;
                    } else if (colorFormat === 'argb2222') {
                        bytesPerPixel = 1;
                    }

                    // è®¡ç®—å•å¼ å›¾ç‰‡å¤§å°
                    const singleImageSize = card.width * card.height * bytesPerPixel;
                    // ä¹˜ä»¥å›¾ç‰‡æ•°é‡
                    totalOutputSize += singleImageSize * card.images.length;
                }
            }

            // å¯ç”¨/ç¦ç”¨è½¬æ¢æŒ‰é’®
            convertBtn.disabled = !allValid;

            // å¯ç”¨/ç¦ç”¨å¯¼å‡ºé¢„è§ˆæŒ‰é’®ï¼ˆå°äº2Mæ‰å…è®¸ï¼‰
            const maxPreviewSize = 2 * 1024 * 1024; // 2MB
            exportPreviewBtn.disabled = !allValid || totalOutputSize >= maxPreviewSize;

            // æ·»åŠ å·¥å…·æç¤º
            if (totalOutputSize >= maxPreviewSize) {
                exportPreviewBtn.title = `å¯¼å‡ºé¢„è§ˆä»…æ”¯æŒå°äº2Mçš„æ–‡ä»¶ï¼Œå½“å‰å¤§å°: ${formatBytes(totalOutputSize)}`;
            } else {
                exportPreviewBtn.title = '';
            }
        }

        // å¹¶å‘æ§åˆ¶å‡½æ•° - é™åˆ¶åŒæ—¶å¤„ç†çš„ä»»åŠ¡æ•°é‡
        async function concurrencyControl(tasks, concurrencyLimit, progressCallback) {
            const results = [];
            const executing = new Set();
            let completedTasks = 0;

            async function executeNext() {
                if (tasks.length === 0) return;

                const task = tasks.shift();
                const promise = task();

                executing.add(promise);

                try {
                    const result = await promise;
                    results.push(result);
                    completedTasks++;

                    // è°ƒç”¨è¿›åº¦å›è°ƒ
                    if (typeof progressCallback === 'function') {
                        progressCallback();
                    }
                } catch (error) {
                    throw error;
                } finally {
                    executing.delete(promise);
                    await executeNext();
                }
            }

            // å¯åŠ¨åˆå§‹å¹¶å‘ä»»åŠ¡
            const initialTasks = Math.min(concurrencyLimit, tasks.length);
            const promises = Array.from({ length: initialTasks }, executeNext);

            await Promise.all(promises);
            return results;
        }

        // è¿›åº¦æ¡æ§åˆ¶å‡½æ•°
        function updateProgress(progress, text) {
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            const progressPercent = document.getElementById('progressPercent');

            // ç¡®ä¿è¿›åº¦ä¸è¶…è¿‡100%
            const percentage = Math.max(0, Math.min(100, Math.round(progress)));
            progressFill.style.width = `${percentage}%`;
            progressText.textContent = text;
            progressPercent.textContent = `${percentage}%`;
        }

        // é‡ç½®è¿›åº¦æ¡
        function resetProgress() {
            updateProgress(0, 'å‡†å¤‡è½¬æ¢...');
        }

        // è®¾å¤‡æ€§èƒ½æ£€æµ‹ - è‡ªåŠ¨è°ƒæ•´å¹¶å‘æ•°
        function getOptimalConcurrency() {
            try {
                // è·å–CPUæ ¸å¿ƒæ•°
                const cpuCores = navigator.hardwareConcurrency || 4;

                // è·å–å¯ç”¨å†…å­˜ï¼ˆè¿‘ä¼¼å€¼ï¼‰
                const memory = navigator.deviceMemory || 4;

                // æ ¹æ®CPUæ ¸å¿ƒæ•°å’Œå†…å­˜è°ƒæ•´å¹¶å‘æ•°
                let concurrency = Math.min(cpuCores * 2, 16); // æœ€å¤š16ä¸ªå¹¶å‘

                // å†…å­˜ä¸è¶³æ—¶é™ä½å¹¶å‘æ•°
                if (memory < 2) {
                    concurrency = Math.min(cpuCores, 4); // å†…å­˜å°äº2GBæ—¶æœ€å¤š4ä¸ªå¹¶å‘
                } else if (memory < 4) {
                    concurrency = Math.min(cpuCores * 1.5, 8); // å†…å­˜å°äº4GBæ—¶æœ€å¤š8ä¸ªå¹¶å‘
                }

                return concurrency;
            } catch (error) {
                // æ€§èƒ½æ£€æµ‹å¤±è´¥æ—¶ä½¿ç”¨ä¿å®ˆå€¼
                return 4;
            }
        }



        // è½¬æ¢æ‰€æœ‰å›¾ç‰‡
        async function convertAllImages() {
            // è·å–å…¨å±€è®¾ç½®
            const colorFormat = document.getElementById('colorFormat').value;
            const outputFormat = document.getElementById('outputFormat').value;
            const filename = document.getElementById('filename').value;

            // æ£€æŸ¥æ–‡ä»¶åæ˜¯å¦ä¸ºç©º
            if (!filename) {
                alert('é”™è¯¯ï¼šæ–‡ä»¶åä¸èƒ½ä¸ºç©ºï¼è¯·è¾“å…¥æœ‰æ•ˆçš„æ–‡ä»¶åã€‚');
                return;
            }

            // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å¡ç‰‡éƒ½é€‰æ‹©äº†å›¾ç‰‡
            for (const card of cards) {
                if (!card.isValid) {
                    alert(`é”™è¯¯ï¼šå›¾ç‰‡ ${card.index + 1} æ²¡æœ‰é€‰æ‹©å›¾ç‰‡ï¼`);
                    return;
                }
            }

            // æ£€æŸ¥æ•°ç»„åå‰ç¼€æ˜¯å¦å”¯ä¸€
            if (!checkArrayPrefixUnique()) {
                alert('é”™è¯¯ï¼šæ•°ç»„åå‰ç¼€å¿…é¡»å”¯ä¸€ï¼è¯·ä¿®æ”¹é‡å¤çš„æ•°ç»„åå‰ç¼€ã€‚');
                return;
            }

            // é‡ç½®å¹¶æ˜¾ç¤ºè¿›åº¦æ¡
            resetProgress();

            // ç¦ç”¨è½¬æ¢æŒ‰é’®
            const convertBtn = document.getElementById('convertBtn');
            convertBtn.disabled = true;

            try {
                if (outputFormat === '.c') {
                    await generateCFileForAllImages(filename, colorFormat);
                } else {
                    // ç”Ÿæˆbinæ–‡ä»¶å’Œå¯¹åº”çš„.cæ–‡ä»¶
                    await generateBinFiles(filename, colorFormat);
                }

                // è½¬æ¢å®Œæˆ
                updateProgress(100, 'è½¬æ¢å®Œæˆï¼');
            } catch (error) {
                // è½¬æ¢å¤±è´¥
                updateProgress(0, 'è½¬æ¢å¤±è´¥ï¼š' + error.message);
                alert('è½¬æ¢å¤±è´¥ï¼š' + error.message);
            } finally {
                // æ¢å¤è½¬æ¢æŒ‰é’®çŠ¶æ€
                convertBtn.disabled = false;
            }
        }

        // ç”Ÿæˆbinæ–‡ä»¶å’Œå¯¹åº”çš„.cæ–‡ä»¶
        async function generateBinFiles(filename, format) {
            // ç”Ÿæˆbinæ–‡ä»¶å¹¶è·å–å›¾ç‰‡æ•°æ®ä¿¡æ¯
            const imageInfo = await generateBinFileForAllImages(filename, format);

            // ç”Ÿæˆå¯¹åº”çš„.cæ–‡ä»¶
            generateBinCFile(filename, format, imageInfo);
        }

        // ç”ŸæˆCæ–‡ä»¶å†…å®¹çš„å…¬å…±å‡½æ•°
        async function generateCFileContentCommon(filename, format, progressCallback) {
            const contentArray = [];
            contentArray.push(`#include <stdint.h>\n`);
            contentArray.push(`#include <sgl_core.h>\n\n`);
            contentArray.push(`// ${filename} - Generated by Image To Array Tool\n\n`);

            // å­˜å‚¨æ‰€æœ‰sgl_pixmap_tç»“æ„ä½“å®šä¹‰
            const pixmapStructuresArray = [];
            // å­˜å‚¨éœ€è¦ç»„åˆä¸ºæ•°ç»„çš„ç»“æ„ä½“ä¿¡æ¯
            const structArrays = [];
            // å­˜å‚¨å¡ç‰‡çš„â€œç»„åˆä¸ºæ•°ç»„â€è®¾ç½®
            const cardCombineSettings = [];

            // æ”¶é›†æ‰€æœ‰éœ€è¦å¤„ç†çš„å›¾ç‰‡ä»»åŠ¡
            const imageTasks = [];
            const totalImages = cards.reduce((sum, card) => sum + card.images.length, 0);
            let processedImages = 0;

            // æ”¶é›†ä»»åŠ¡å’Œå¡ç‰‡è®¾ç½®
            for (let cardIndex = 0; cardIndex < cards.length; cardIndex++) {
                const card = cards[cardIndex];
                const cardElement = document.querySelector(`[data-card-index="${cardIndex}"]`);
                // è·å–â€œç»„åˆä¸ºæ•°ç»„â€å•é€‰æ¡†çŠ¶æ€ï¼Œé»˜è®¤é€‰ä¸­
                const combineAsArray = cardElement.querySelector('.combine-as-array')?.checked ?? true;
                cardCombineSettings[cardIndex] = combineAsArray;

                // æ·»åŠ å½“å‰å¡ç‰‡çš„æ‰€æœ‰å›¾ç‰‡å¤„ç†ä»»åŠ¡
                for (let imgIndex = 0; imgIndex < card.images.length; imgIndex++) {
                    const imageItem = card.images[imgIndex];
                    // åˆ›å»ºå›¾ç‰‡å¤„ç†ä»»åŠ¡
                    imageTasks.push(async () => {
                        const result = await processImageForC(card, imageItem, imgIndex, cardIndex, format);
                        // è°ƒç”¨è¿›åº¦å›è°ƒ
                        if (typeof progressCallback === 'function') {
                            processedImages++;
                            progressCallback(processedImages, totalImages);
                        }
                        return result;
                    });
                }
            }

            // è·å–æœ€ä½³å¹¶å‘æ•°
            const optimalConcurrency = getOptimalConcurrency();
            // æ‰§è¡Œå¹¶å‘ä»»åŠ¡
            const results = await concurrencyControl(imageTasks, optimalConcurrency);

            // å¤„ç†ç»“æœï¼ŒæŒ‰é¡ºåºç”Ÿæˆå†…å®¹
            // é¦–å…ˆæŒ‰å¡ç‰‡å’Œå›¾ç‰‡ç´¢å¼•æ’åºç»“æœï¼Œç¡®ä¿ç”Ÿæˆçš„é¡ºåºæ­£ç¡®
            results.sort((a, b) => {
                if (a.cardIndex !== b.cardIndex) {
                    return a.cardIndex - b.cardIndex;
                }
                return a.imgIndex - b.imgIndex;
            });

            // éå†å¤„ç†ç»“æœ
            let currentCardIndex = -1;
            const cardStructs = {};

            for (const result of results) {
                const { cardIndex, imgIndex } = result;

                // åˆå§‹åŒ–å½“å‰å¡ç‰‡çš„ç»“æ„ä½“æ•°ç»„
                if (currentCardIndex !== cardIndex) {
                    currentCardIndex = cardIndex;
                    cardStructs[currentCardIndex] = [];
                }

                // æ·»åŠ æ•°ç»„å®šä¹‰
                contentArray.push(`// ${result.arrayPrefix} - ${result.width}x${result.height} ${format.toUpperCase()}${result.useRle ? ' (RLEå‹ç¼©)' : ''}\n`);
                contentArray.push(`static const uint8_t ${result.arrayPrefix}_data[${result.arraySize}] = {\n    ${result.pixelData}\n};\n\n`);

                // ç”Ÿæˆç»“æ„ä½“åç§°
                const structName = `${result.arrayPrefix}_pixmap`;

                // å­˜å‚¨ç»“æ„ä½“ä¿¡æ¯
                cardStructs[currentCardIndex].push({
                    name: structName,
                    arrayPrefix: result.arrayPrefix,
                    formatValue: result.formatValue,
                    width: result.width,
                    height: result.height,
                    imgIndex: result.imgIndex
                });
            }

            // å¤„ç†ç»“æ„ä½“ç”Ÿæˆé€»è¾‘
            for (let cardIndex = 0; cardIndex < cards.length; cardIndex++) {
                const combineAsArray = cardCombineSettings[cardIndex];
                const structs = cardStructs[cardIndex] || [];
                const card = cards[cardIndex];

                if (combineAsArray) {
                    // å‹¾é€‰äº†"ç»„åˆä¸ºæ•°ç»„"
                    if (structs.length >= 2) {
                        // å›¾ç‰‡æ•°é‡>=2ï¼Œç”Ÿæˆç»“æ„ä½“æ•°ç»„
                        structArrays.push({
                            card: card,
                            structs: structs
                        });
                    } else {
                        // å›¾ç‰‡æ•°é‡=1ï¼Œç”Ÿæˆå•ä¸ªç»“æ„ä½“
                        const struct = structs[0];
                        if (struct) {
                            pixmapStructuresArray.push(`// é€‰é¡¹å¡ ${cardIndex + 1} å›¾ç‰‡ ${struct.imgIndex + 1} çš„sgl_pixmap_tç»“æ„ä½“\n`);
                            pixmapStructuresArray.push(`const sgl_pixmap_t ${struct.name} = {\n`);
                            pixmapStructuresArray.push(`    .width = ${struct.width},\n`);
                            pixmapStructuresArray.push(`    .height = ${struct.height},\n`);
                            pixmapStructuresArray.push(`    .bitmap.array = ${struct.arrayPrefix}_data,\n`);
                            pixmapStructuresArray.push(`    .format = ${struct.formatValue},\n`);
                            pixmapStructuresArray.push(`};\n\n`);
                        }
                    }
                } else {
                    // å–æ¶ˆå‹¾é€‰"ç»„åˆä¸ºæ•°ç»„"ï¼Œç”Ÿæˆå•ä¸ªç»“æ„ä½“
                    for (const struct of structs) {
                        pixmapStructuresArray.push(`// é€‰é¡¹å¡ ${cardIndex + 1} å›¾ç‰‡ ${struct.imgIndex + 1} çš„sgl_pixmap_tç»“æ„ä½“\n`);
                        pixmapStructuresArray.push(`const sgl_pixmap_t ${struct.name} = {\n`);
                        pixmapStructuresArray.push(`    .width = ${struct.width},\n`);
                        pixmapStructuresArray.push(`    .height = ${struct.height},\n`);
                        pixmapStructuresArray.push(`    .bitmap.array = ${struct.arrayPrefix}_data,\n`);
                        pixmapStructuresArray.push(`    .format = ${struct.formatValue},\n`);
                        pixmapStructuresArray.push(`};\n\n`);
                    }
                }
            }

            // å°†æ‰€æœ‰å•ç‹¬çš„sgl_pixmap_tç»“æ„ä½“å®šä¹‰æ·»åŠ åˆ°æ–‡ä»¶
            if (pixmapStructuresArray.length > 0) {
                contentArray.push(`// æ‰€æœ‰å›¾ç‰‡çš„sgl_pixmap_tç»“æ„ä½“å®šä¹‰\n`);
                contentArray.push(...pixmapStructuresArray);
            }

            // ç”Ÿæˆç»“æ„ä½“æ•°ç»„å®šä¹‰
            for (const structArray of structArrays) {
                const card = structArray.card;
                const structs = structArray.structs;

                // ç”Ÿæˆæ•°ç»„åç§°
                const arrayName = `${card.arrayPrefix}_array`;

                // æ·»åŠ ç»“æ„ä½“æ•°ç»„å®šä¹‰
                contentArray.push(`// ${card.arrayPrefix} ç»“æ„ä½“æ•°ç»„ - ${structs.length}å¼ å›¾ç‰‡\n`);
                contentArray.push(`const sgl_pixmap_t ${arrayName}[${structs.length}] = {\n`);

                for (let i = 0; i < structs.length; i++) {
                    const struct = structs[i];
                    contentArray.push(`    {\n`);
                    contentArray.push(`        .width = ${struct.width},\n`);
                    contentArray.push(`        .height = ${struct.height},\n`);
                    contentArray.push(`        .bitmap.array = ${struct.arrayPrefix}_data,\n`);
                    contentArray.push(`        .format = ${struct.formatValue}\n`);
                    contentArray.push(`    }${i < structs.length - 1 ? ',' : ''}\n`);
                }

                contentArray.push(`};\n\n`);
            }

            return contentArray.join('');
        }

        // ç”Ÿæˆæ‰€æœ‰å›¾ç‰‡çš„Cæ–‡ä»¶
        async function generateCFileForAllImages(filename, format) {
            // å®šä¹‰è¿›åº¦æ›´æ–°å›è°ƒ
            const updateProgressCallback = (processed, total) => {
                const progress = Math.min(90, (processed / total) * 90); // 90%ç”¨äºå›¾ç‰‡å¤„ç†ï¼Œç•™10%ç»™æ–‡ä»¶ç”Ÿæˆ
                updateProgress(progress, `æ­£åœ¨å¤„ç†å›¾ç‰‡ ${processed}/${total}...`);
            };

            // ç”ŸæˆCæ–‡ä»¶å†…å®¹
            const content = await generateCFileContentCommon(filename, format, updateProgressCallback);

            updateProgress(90, 'æ­£åœ¨ç”Ÿæˆæ–‡ä»¶...');

            // ä¸‹è½½æ–‡ä»¶
            downloadFile(`${filename}.c`, content);
        }

        // ç”Ÿæˆæ‰€æœ‰å›¾ç‰‡çš„BINæ–‡ä»¶
        async function generateBinFileForAllImages(filename, format) {
            // å…ˆæ”¶é›†æ‰€æœ‰å¡ç‰‡çš„åƒç´ æ•°æ®
            let totalSize = 0;
            const imageInfo = [];

            // è®¡ç®—æ€»å›¾ç‰‡æ•°é‡ï¼ˆæ‰€æœ‰é€‰é¡¹å¡çš„å›¾ç‰‡æ€»å’Œï¼‰
            const totalImages = cards.reduce((sum, card) => sum + card.images.length, 0);
            let processedImages = 0;

            // æ”¶é›†æ‰€æœ‰éœ€è¦å¤„ç†çš„å›¾ç‰‡ä»»åŠ¡
            const imageTasks = [];

            // æ”¶é›†ä»»åŠ¡
            for (let cardIndex = 0; cardIndex < cards.length; cardIndex++) {
                const card = cards[cardIndex];

                // æ·»åŠ å½“å‰å¡ç‰‡çš„æ‰€æœ‰å›¾ç‰‡å¤„ç†ä»»åŠ¡
                for (let imgIndex = 0; imgIndex < card.images.length; imgIndex++) {
                    const imageItem = card.images[imgIndex];
                    // åˆ›å»ºå›¾ç‰‡å¤„ç†ä»»åŠ¡
                    imageTasks.push(async () => {
                        return await processImageForBin(card, imageItem, imgIndex, cardIndex, format);
                    });
                }
            }

            // å®šä¹‰è¿›åº¦æ›´æ–°å›è°ƒ
            const updateProgressCallback = () => {
                processedImages++;
                const progress = Math.min(90, (processedImages / totalImages) * 90); // 90%ç”¨äºå›¾ç‰‡å¤„ç†ï¼Œç•™10%ç»™æ–‡ä»¶ç”Ÿæˆ
                updateProgress(progress, `æ­£åœ¨å¤„ç†å›¾ç‰‡ ${processedImages}/${totalImages}...`);
            };

            // è·å–æœ€ä½³å¹¶å‘æ•°
            const optimalConcurrency = getOptimalConcurrency();
            // æ‰§è¡Œå¹¶å‘ä»»åŠ¡
            const results = await concurrencyControl(imageTasks, optimalConcurrency, updateProgressCallback);

            // å¤„ç†ç»“æœï¼ŒæŒ‰é¡ºåºç”Ÿæˆå†…å®¹
            // é¦–å…ˆæŒ‰å¡ç‰‡å’Œå›¾ç‰‡ç´¢å¼•æ’åºç»“æœï¼Œç¡®ä¿ç”Ÿæˆçš„é¡ºåºæ­£ç¡®
            results.sort((a, b) => {
                if (a.cardIndex !== b.cardIndex) {
                    return a.cardIndex - b.cardIndex;
                }
                return a.imgIndex - b.imgIndex;
            });

            // è®¡ç®—æ€»æ•°æ®å¤§å°
            for (const result of results) {
                totalSize += result.finalBytes.length;
            }

            // åˆ›å»ºArrayBuffer
            const arrayBuffer = new ArrayBuffer(totalSize);
            const view = new DataView(arrayBuffer);
            let currentOffset = 0;

            // éå†å¤„ç†ç»“æœï¼Œç›´æ¥å†™å…¥ArrayBuffer
            for (const result of results) {
                // è®°å½•å½“å‰å›¾ç‰‡çš„èµ·å§‹åœ°å€
                const startAddress = currentOffset;

                // ç›´æ¥å°†æ•°æ®å†™å…¥ArrayBuffer
                for (let i = 0; i < result.finalBytes.length; i++) {
                    view.setUint8(currentOffset++, result.finalBytes[i]);
                }

                // å­˜å‚¨å›¾ç‰‡ä¿¡æ¯
                imageInfo.push({
                    card: result.card,
                    name: result.arrayPrefix,
                    startAddress: startAddress,
                    dataSize: result.finalBytes.length,
                    format: result.formatValue,
                    width: result.width,
                    height: result.height
                });
            }

            updateProgress(90, 'æ­£åœ¨ç”Ÿæˆæ–‡ä»¶...');

            // ä¸‹è½½æ–‡ä»¶
            const blob = new Blob([arrayBuffer], { type: 'application/octet-stream' });
            downloadFile(`${filename}.bin`, blob);

            // è¿”å›å›¾ç‰‡ä¿¡æ¯æ•°ç»„
            return imageInfo;
        }

        // ç”ŸæˆBINæ ¼å¼å¯¹åº”çš„Cæ–‡ä»¶
        function generateBinCFile(filename, format, imageInfo) {
            const contentArray = [];
            contentArray.push(`#include <stdint.h>\n`);
            contentArray.push(`#include <sgl_core.h>\n\n`);
            contentArray.push(`// ${filename} - Generated by Image To Array Tool\n\n`);

            // ç”Ÿæˆsgl_pixmap_tç»“æ„ä½“
            contentArray.push(`// å›¾ç‰‡æ•°æ®ç»“æ„ä½“å®šä¹‰\n`);

            // æŒ‰å¡ç‰‡åˆ†ç»„å›¾ç‰‡ä¿¡æ¯
            const cardGroups = {};
            imageInfo.forEach(info => {
                if (!cardGroups[info.card.arrayPrefix]) {
                    cardGroups[info.card.arrayPrefix] = [];
                }
                cardGroups[info.card.arrayPrefix].push(info);
            });

            // éå†æ¯ä¸ªå¡ç‰‡ç»„
            for (const [prefix, infos] of Object.entries(cardGroups)) {
                const card = infos[0].card;
                const cardElement = document.querySelector(`[data-card-index="${card.index}"]`);
                // è·å–â€œç»„åˆä¸ºæ•°ç»„â€å•é€‰æ¡†çŠ¶æ€ï¼Œé»˜è®¤é€‰ä¸­
                const combineAsArray = cardElement.querySelector('.combine-as-array')?.checked ?? true;

                if (combineAsArray && infos.length > 1) {
                    // ç»„åˆä¸ºæ•°ç»„
                    contentArray.push(`// ${prefix} ç»“æ„ä½“æ•°ç»„ - ${infos.length}å¼ å›¾ç‰‡\n`);
                    contentArray.push(`const sgl_pixmap_t ${prefix}_array[${infos.length}] = {\n`);

                    for (let i = 0; i < infos.length; i++) {
                        const info = infos[i];
                        contentArray.push(`    {\n`);
                        contentArray.push(`        .width = ${info.width},\n`);
                        contentArray.push(`        .height = ${info.height},\n`);
                        contentArray.push(`        .bitmap.addr = 0x${info.startAddress.toString(16).padStart(8, '0')}, // å›¾ç‰‡åœ¨BINæ–‡ä»¶ä¸­çš„èµ·å§‹åœ°å€\n`);
                        contentArray.push(`        .format = ${info.format}\n`);
                        contentArray.push(`    }${i < infos.length - 1 ? ',' : ''}\n`);
                    }

                    contentArray.push(`};\n\n`);
                } else {
                    // å•ç‹¬è¾“å‡º
                    for (const info of infos) {
                        contentArray.push(`// ${info.name} - ${info.width}x${info.height} ${format.toUpperCase()}${info.format.includes('RLE') ? ' (RLEå‹ç¼©)' : ''}\n`);
                        contentArray.push(`const sgl_pixmap_t ${info.name}_pixmap = {\n`);
                        contentArray.push(`    .width = ${info.width},\n`);
                        contentArray.push(`    .height = ${info.height},\n`);
                        contentArray.push(`    .bitmap.addr = 0x${info.startAddress.toString(16).padStart(8, '0')}, // å›¾ç‰‡åœ¨BINæ–‡ä»¶ä¸­çš„èµ·å§‹åœ°å€\n`);
                        contentArray.push(`    .format = ${info.format},\n`);
                        contentArray.push(`};\n\n`);
                    }
                }
            }

            // ä¸‹è½½æ–‡ä»¶
            downloadFile(`${filename}.c`, contentArray.join(''));
        }

        // RLEå‹ç¼©ç®—æ³• - æŒ‰åƒç´ ä¸ºå•ä½å‹ç¼©
        function rleCompress(data, colorFormat) {
            if (!data || data.length === 0) {
                return [];
            }

            // æ ¹æ®é¢œè‰²æ ¼å¼ç¡®å®šæ¯ä¸ªåƒç´ çš„å­—èŠ‚æ•°
            let bytesPerPixel = 3; // é»˜è®¤RGB888
            if (colorFormat === 'rgb565') {
                bytesPerPixel = 2;
            } else if (colorFormat === 'rgb332') {
                bytesPerPixel = 1;
            } else if (colorFormat === 'argb8888') {
                bytesPerPixel = 4;
            } else if (colorFormat === 'argb4444') {
                bytesPerPixel = 2;
            } else if (colorFormat === 'argb2222') {
                bytesPerPixel = 1;
            }

            const compressed = [];
            const dataLength = data.length;

            // ç¡®ä¿æ•°æ®é•¿åº¦æ˜¯åƒç´ å­—èŠ‚æ•°çš„æ•´æ•°å€
            if (dataLength % bytesPerPixel !== 0) {
                return Array.isArray(data) ? data : Array.from(data); // æ•°æ®æ ¼å¼é”™è¯¯ï¼Œè¿”å›åŸå§‹æ•°æ®
            }

            // è®¡ç®—æ€»åƒç´ æ•°
            const pixelCount = dataLength / bytesPerPixel;
            if (pixelCount === 0) {
                return [];
            }

            // éå†æ‰€æœ‰åƒç´ ï¼Œç›´æ¥æ¯”è¾ƒåŸå§‹æ•°æ®ï¼Œé¿å…åˆ›å»ºä¸´æ—¶æ•°ç»„
            let count = 1;

            // éå†æ‰€æœ‰åƒç´ 
            for (let i = bytesPerPixel; i < dataLength; i += bytesPerPixel) {
                // æ£€æŸ¥å½“å‰åƒç´ æ˜¯å¦ä¸å‰ä¸€ä¸ªåƒç´ ç›¸åŒ
                let isSamePixel = true;
                for (let j = 0; j < bytesPerPixel; j++) {
                    if (data[i + j] !== data[i - bytesPerPixel + j]) {
                        isSamePixel = false;
                        break;
                    }
                }

                if (isSamePixel && count < 255) {
                    // ç›¸åŒåƒç´ ä¸”è®¡æ•°æœªè¾¾ä¸Šé™ï¼Œç»§ç»­è®¡æ•°
                    count++;
                } else {
                    // é‡åˆ°ä¸åŒåƒç´ æˆ–è®¡æ•°ä¸Šé™ï¼Œè¾“å‡ºå‹ç¼©å•å…ƒ
                    compressed.push(count); // å­˜å‚¨è¿ç»­åƒç´ æ•°é‡
                    // å­˜å‚¨åƒç´ æ•°æ®ï¼Œç›´æ¥è®¿é—®åŸå§‹æ•°æ®
                    for (let j = 0; j < bytesPerPixel; j++) {
                        compressed.push(data[i - bytesPerPixel + j]);
                    }

                    // é‡ç½®è®¡æ•°
                    count = 1;
                }
            }

            // æ·»åŠ æœ€åä¸€ç»„åƒç´ æ•°æ®
            compressed.push(count);
            // å­˜å‚¨æœ€åä¸€ç»„åƒç´ æ•°æ®
            for (let j = 0; j < bytesPerPixel; j++) {
                compressed.push(data[dataLength - bytesPerPixel + j]);
            }

            return compressed;
        }

        // å•å¼ å›¾ç‰‡å¤„ç†å‡½æ•° - ç”¨äºCæ–‡ä»¶ç”Ÿæˆ
        async function processImageForC(card, imageItem, imgIndex, cardIndex, format) {
            // ç¼“å­˜DOMå…ƒç´ å¼•ç”¨
            const transparentFillCheckbox = document.getElementById('transparentFill');
            const fillColorInput = document.getElementById('fillColor');
            const reverseOrderCheckbox = document.getElementById('reverseOrder');
            const compressionAlgorithmSelect = document.getElementById('compressionAlgorithm');

            // åˆ›å»ºcanvasè¿›è¡Œå›¾ç‰‡å¤„ç†
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = card.width;
            canvas.height = card.height;

            // ç»˜åˆ¶å›¾ç‰‡
            const img = new Image();
            await new Promise((resolve) => {
                img.onload = resolve;
                img.src = imageItem.previewUrl;
            });

            // æ£€æŸ¥æ˜¯å¦å¯ç”¨é€æ˜å¡«å……
            const useTransparentFill = transparentFillCheckbox.checked;
            let fillR = 255, fillG = 255, fillB = 255;

            if (useTransparentFill) {
                // è·å–å¡«å……é¢œè‰²
                const fillColor = fillColorInput.value.trim().toUpperCase();
                if (/^[0-9A-F]{6}$/.test(fillColor)) {
                    // è§£æRGBå€¼
                    fillR = parseInt(fillColor.substring(0, 2), 16);
                    fillG = parseInt(fillColor.substring(2, 4), 16);
                    fillB = parseInt(fillColor.substring(4, 6), 16);
                }
            }

            // åˆ›å»ºä¸´æ—¶canvaså¤„ç†é€æ˜åº¦
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = card.width;
            tempCanvas.height = card.height;
            const tempCtx = tempCanvas.getContext('2d');

            // å¦‚æœå¯ç”¨é€æ˜å¡«å……ï¼Œå…ˆç»˜åˆ¶å¡«å……é¢œè‰²ï¼Œå†ç»˜åˆ¶å›¾ç‰‡
            if (useTransparentFill) {
                // ç»˜åˆ¶å¡«å……é¢œè‰²
                tempCtx.fillStyle = `rgb(${fillR}, ${fillG}, ${fillB})`;
                tempCtx.fillRect(0, 0, card.width, card.height);
                // ç»˜åˆ¶å›¾ç‰‡ï¼ˆä¼šä¸èƒŒæ™¯è‰²æ··åˆé€æ˜åƒç´ ï¼‰
                tempCtx.drawImage(img, 0, 0, card.width, card.height);
            } else {
                // ç›´æ¥ç»˜åˆ¶å›¾ç‰‡
                tempCtx.drawImage(img, 0, 0, card.width, card.height);
            }

            // è·å–å›¾ç‰‡æ•°æ®
            let imageData = tempCtx.getImageData(0, 0, card.width, card.height);
            // åº”ç”¨é¢œè‰²æ·±åº¦è¿‡æ»¤
            imageData = processImageData(imageData, format);
            const data = imageData.data;

            // ç¼“å­˜åå­—åºè®¾ç½®
            const isReverseOrder = reverseOrderCheckbox.checked;

            // ç”Ÿæˆåƒç´ æ•°æ®æ•°ç»„
            const pixelBytes = [];

            // é€è¡Œå¤„ç†åƒç´ æ•°æ®
            for (let y = 0; y < card.height; y++) {
                for (let x = 0; x < card.width; x++) {
                    const index = (y * card.width + x) * 4;
                    let r = data[index];
                    let g = data[index + 1];
                    let b = data[index + 2];
                    const a = data[index + 3]; // é€æ˜åº¦é€šé“

                        // æ™®é€šæ¨¡å¼
                        if (format === 'rgb888') {
                            // æ£€æŸ¥åå­—åºè®¾ç½®
                            if (isReverseOrder) {
                                // BGRé¡ºåº
                                pixelBytes.push(b);
                                pixelBytes.push(g);
                                pixelBytes.push(r);
                            } else {
                                // RGBé¡ºåº
                                pixelBytes.push(r);
                                pixelBytes.push(g);
                                pixelBytes.push(b);
                            }
                        } else if (format === 'rgb565') {
                            // RGB565æ ¼å¼ï¼š2å­—èŠ‚
                            const r5 = (r >> 3) & 0x1F;
                            const g6 = (g >> 2) & 0x3F;
                            const b5 = (b >> 3) & 0x1F;
                            const value = (r5 << 11) | (g6 << 5) | b5;
                            const lowByte = value & 0xFF;
                            const highByte = (value >> 8) & 0xFF;

                            // æ£€æŸ¥åå­—åºè®¾ç½®
                            if (isReverseOrder) {
                                // ä½å­—èŠ‚åœ¨å‰ï¼Œé«˜å­—èŠ‚åœ¨åï¼ˆå°ç«¯åºï¼‰
                                pixelBytes.push(lowByte);
                                pixelBytes.push(highByte);
                            } else {
                                // é«˜å­—èŠ‚åœ¨å‰ï¼Œä½å­—èŠ‚åœ¨åï¼ˆå¤§ç«¯åºï¼‰
                                pixelBytes.push(highByte);
                                pixelBytes.push(lowByte);
                            }
                        } else if (format === 'rgb332') {
                            // RGB332æ ¼å¼ï¼š1å­—èŠ‚
                            const r3 = (r >> 5) & 0x07;
                            const g3 = (g >> 5) & 0x07;
                            const b2 = (b >> 6) & 0x03;
                            const value = (r3 << 5) | (g3 << 2) | b2;
                            pixelBytes.push(value);
                        } else if (format === 'argb8888') {
                            // æ£€æŸ¥åå­—åºè®¾ç½®
                            if (isReverseOrder) {
                                // B+G+R+Aé¡ºåº
                                pixelBytes.push(b);
                                pixelBytes.push(g);
                                pixelBytes.push(r);
                                pixelBytes.push(a);
                            } else {
                                // A+R+G+Bé¡ºåº
                                pixelBytes.push(a);
                                pixelBytes.push(r);
                                pixelBytes.push(g);
                                pixelBytes.push(b);
                            }
                        } else if (format === 'argb4444') {
                            // ARGB4444æ ¼å¼ï¼š2å­—èŠ‚ï¼ŒA(4bit),R(4bit),G(4bit),B(4bit)
                            const a4 = (a >> 4) & 0x0F;
                            const r4 = (r >> 4) & 0x0F;
                            const g4 = (g >> 4) & 0x0F;
                            const b4 = (b >> 4) & 0x0F;
                            const value = (a4 << 12) | (r4 << 8) | (g4 << 4) | b4;
                            const lowByte = value & 0xFF;
                            const highByte = (value >> 8) & 0xFF;

                            // æ£€æŸ¥åå­—åºè®¾ç½®
                            if (isReverseOrder) {
                                // ä½å­—èŠ‚åœ¨å‰ï¼Œé«˜å­—èŠ‚åœ¨åï¼ˆå°ç«¯åºï¼‰
                                pixelBytes.push(lowByte);
                                pixelBytes.push(highByte);
                            } else {
                                // é«˜å­—èŠ‚åœ¨å‰ï¼Œä½å­—èŠ‚åœ¨åï¼ˆå¤§ç«¯åºï¼‰
                                pixelBytes.push(highByte);
                                pixelBytes.push(lowByte);
                            }
                        } else if (format === 'argb2222') {
                            // ARGB2222æ ¼å¼ï¼š1å­—èŠ‚ï¼ŒA(2bit),R(2bit),G(2bit),B(2bit)
                            const a2 = (a >> 6) & 0x03;
                            const r2 = (r >> 6) & 0x03;
                            const g2 = (g >> 6) & 0x03;
                            const b2 = (b >> 6) & 0x03;
                            const value = (a2 << 6) | (r2 << 4) | (g2 << 2) | b2;
                            pixelBytes.push(value);
                        }
                }
            }

            // æ£€æŸ¥æ˜¯å¦å¯ç”¨å‹ç¼©
            const useRle = compressionAlgorithmSelect.value === 'rle';
            // åº”ç”¨RLEå‹ç¼©
            let finalBytes = pixelBytes;
            if (useRle) {
                finalBytes = rleCompress(pixelBytes, format);
            }

            // å°†å‹ç¼©åçš„æ•°æ®è½¬æ¢ä¸ºCæ•°ç»„æ ¼å¼
            const pixelDataArray = [];
            let count = 0;

            for (let j = 0; j < finalBytes.length; j++) {
                const byte = finalBytes[j];
                pixelDataArray.push(`0x${byte.toString(16).padStart(2, '0')}`);
                count++;

                if (count >= 24) {
                    pixelDataArray.push(',\n    ');
                    count = 0;
                } else if (j < finalBytes.length - 1) {
                    pixelDataArray.push(', ');
                }
            }

            const pixelData = pixelDataArray.join('');

            // è®¡ç®—æ•°ç»„å¤§å°
            const arraySize = finalBytes.length;

            // ç”Ÿæˆæ•°ç»„åç§°ï¼Œç¬¬ä¸€å¼ å›¾ç‰‡ç›´æ¥ä½¿ç”¨å‰ç¼€ï¼Œåç»­å›¾ç‰‡æ·»åŠ _1,_2ç­‰
            const arrayPrefix = imgIndex === 0 ? card.arrayPrefix : `${card.arrayPrefix}_${imgIndex}`;

            // ç¡®å®šformatå­—æ®µå€¼
            let formatValue = 'SGL_PIXMAP_FMT_NONE';
            if (useRle) {
                if (format === 'rgb888') {
                    formatValue = 'SGL_PIXMAP_FMT_RLE_RGB888';
                } else if (format === 'rgb565') {
                    formatValue = 'SGL_PIXMAP_FMT_RLE_RGB565';
                } else if (format === 'rgb332') {
                    formatValue = 'SGL_PIXMAP_FMT_RLE_RGB332';
                } else if (format === 'argb8888') {
                    formatValue = 'SGL_PIXMAP_FMT_RLE_ARGB8888';
                } else if (format === 'argb4444') {
                    formatValue = 'SGL_PIXMAP_FMT_RLE_ARGB4444';
                } else if (format === 'argb2222') {
                    formatValue = 'SGL_PIXMAP_FMT_RLE_ARGB2222';
                }
            } else {
                if (format === 'rgb888') {
                    formatValue = 'SGL_PIXMAP_FMT_RGB888';
                } else if (format === 'rgb565') {
                    formatValue = 'SGL_PIXMAP_FMT_RGB565';
                } else if (format === 'rgb332') {
                    formatValue = 'SGL_PIXMAP_FMT_RGB332';
                } else if (format === 'argb8888') {
                    formatValue = 'SGL_PIXMAP_FMT_ARGB8888';
                } else if (format === 'argb4444') {
                    formatValue = 'SGL_PIXMAP_FMT_ARGB4444';
                } else if (format === 'argb2222') {
                    formatValue = 'SGL_PIXMAP_FMT_ARGB2222';
                }
            }

            // è¿”å›å¤„ç†ç»“æœ
            return {
                arrayPrefix: arrayPrefix,
                pixelData: pixelData,
                arraySize: arraySize,
                formatValue: formatValue,
                imgIndex: imgIndex,
                cardIndex: cardIndex,
                width: card.width,
                height: card.height,
                useRle: useRle
            };
        }

        // å•å¼ å›¾ç‰‡å¤„ç†å‡½æ•° - ç”¨äºBINæ–‡ä»¶ç”Ÿæˆ
        async function processImageForBin(card, imageItem, imgIndex, cardIndex, format) {
            // ç¼“å­˜DOMå…ƒç´ å¼•ç”¨
            const transparentFillCheckbox = document.getElementById('transparentFill');
            const fillColorInput = document.getElementById('fillColor');
            const reverseOrderCheckbox = document.getElementById('reverseOrder');
            const compressionAlgorithmSelect = document.getElementById('compressionAlgorithm');

            // åˆ›å»ºcanvasè¿›è¡Œå›¾ç‰‡å¤„ç†
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = card.width;
            canvas.height = card.height;

            // ç»˜åˆ¶å›¾ç‰‡
            const img = new Image();
            await new Promise((resolve) => {
                img.onload = resolve;
                img.src = imageItem.previewUrl;
            });

            // æ£€æŸ¥æ˜¯å¦å¯ç”¨é€æ˜å¡«å……
            const useTransparentFill = transparentFillCheckbox.checked;
            let fillR = 255, fillG = 255, fillB = 255;

            if (useTransparentFill) {
                // è·å–å¡«å……é¢œè‰²
                const fillColor = fillColorInput.value.trim().toUpperCase();
                if (/^[0-9A-F]{6}$/.test(fillColor)) {
                    // è§£æRGBå€¼
                    fillR = parseInt(fillColor.substring(0, 2), 16);
                    fillG = parseInt(fillColor.substring(2, 4), 16);
                    fillB = parseInt(fillColor.substring(4, 6), 16);
                }
            }

            // åˆ›å»ºä¸´æ—¶canvaså¤„ç†é€æ˜åº¦
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = card.width;
            tempCanvas.height = card.height;
            const tempCtx = tempCanvas.getContext('2d');

            // å¦‚æœå¯ç”¨é€æ˜å¡«å……ï¼Œå…ˆç»˜åˆ¶å¡«å……é¢œè‰²ï¼Œå†ç»˜åˆ¶å›¾ç‰‡
            if (useTransparentFill) {
                // ç»˜åˆ¶å¡«å……é¢œè‰²
                tempCtx.fillStyle = `rgb(${fillR}, ${fillG}, ${fillB})`;
                tempCtx.fillRect(0, 0, card.width, card.height);
                // ç»˜åˆ¶å›¾ç‰‡ï¼ˆä¼šä¸èƒŒæ™¯è‰²æ··åˆé€æ˜åƒç´ ï¼‰
                tempCtx.drawImage(img, 0, 0, card.width, card.height);
            } else {
                // ç›´æ¥ç»˜åˆ¶å›¾ç‰‡
                tempCtx.drawImage(img, 0, 0, card.width, card.height);
            }

            // è·å–å›¾ç‰‡æ•°æ®
            let imageData = tempCtx.getImageData(0, 0, card.width, card.height);
            // åº”ç”¨é¢œè‰²æ·±åº¦è¿‡æ»¤
            imageData = processImageData(imageData, format);
            const data = imageData.data;

            // è®¡ç®—å½“å‰å›¾ç‰‡çš„å­—èŠ‚æ•°
            let pixelCount = card.width * card.height;
            let bytesPerPixel = 3;
            if (format === 'rgb565') {
                bytesPerPixel = 2;
            } else if (format === 'rgb332') {
                bytesPerPixel = 1;
            } else if (format === 'argb8888') {
                bytesPerPixel = 4;
            } else if (format === 'argb4444') {
                bytesPerPixel = 2;
            } else if (format === 'argb2222') {
                bytesPerPixel = 1;
            }

            // ç›´æ¥è®¡ç®—æ•°æ®ï¼Œé¿å…ä½¿ç”¨pushæ–¹æ³•
            let imageBytes = new Uint8Array(pixelCount * bytesPerPixel);
            let byteIndex = 0;

            // é€è¡Œå¤„ç†åƒç´ æ•°æ®
            for (let y = 0; y < card.height; y++) {
                for (let x = 0; x < card.width; x++) {
                    const index = (y * card.width + x) * 4;
                    let r = data[index];
                    let g = data[index + 1];
                    let b = data[index + 2];
                    const a = data[index + 3]; // é€æ˜åº¦é€šé“

                        // ç¼“å­˜åå­—åºè®¾ç½®
                        const isReverseOrder = reverseOrderCheckbox.checked;

                        // æ™®é€šæ¨¡å¼
                        if (format === 'rgb888') {
                            // æ£€æŸ¥åå­—åºè®¾ç½®
                            if (isReverseOrder) {
                                // BGRé¡ºåº
                                imageBytes[byteIndex++] = b;
                                imageBytes[byteIndex++] = g;
                                imageBytes[byteIndex++] = r;
                            } else {
                                // RGBé¡ºåº
                                imageBytes[byteIndex++] = r;
                                imageBytes[byteIndex++] = g;
                                imageBytes[byteIndex++] = b;
                            }
                        } else if (format === 'rgb565') {
                            // RGB565æ ¼å¼ï¼š2å­—èŠ‚
                            const r5 = (r >> 3) & 0x1F;
                            const g6 = (g >> 2) & 0x3F;
                            const b5 = (b >> 3) & 0x1F;
                            const value = (r5 << 11) | (g6 << 5) | b5;
                            const lowByte = value & 0xFF;
                            const highByte = (value >> 8) & 0xFF;

                            // æ£€æŸ¥åå­—åºè®¾ç½®
                            if (isReverseOrder) {
                                // ä½å­—èŠ‚åœ¨å‰ï¼Œé«˜å­—èŠ‚åœ¨åï¼ˆå°ç«¯åºï¼‰
                                imageBytes[byteIndex++] = lowByte;
                                imageBytes[byteIndex++] = highByte;
                            } else {
                                // é«˜å­—èŠ‚åœ¨å‰ï¼Œä½å­—èŠ‚åœ¨åï¼ˆå¤§ç«¯åºï¼‰
                                imageBytes[byteIndex++] = highByte;
                                imageBytes[byteIndex++] = lowByte;
                            }
                        } else if (format === 'rgb332') {
                            // RGB332æ ¼å¼ï¼š1å­—èŠ‚
                            const r3 = (r >> 5) & 0x07;
                            const g3 = (g >> 5) & 0x07;
                            const b2 = (b >> 6) & 0x03;
                            const value = (r3 << 5) | (g3 << 2) | b2;
                            imageBytes[byteIndex++] = value;
                        } else if (format === 'argb8888') {
                            // æ£€æŸ¥åå­—åºè®¾ç½®
                            if (isReverseOrder) {
                                // B+G+R+Aé¡ºåº
                                imageBytes[byteIndex++] = b;
                                imageBytes[byteIndex++] = g;
                                imageBytes[byteIndex++] = r;
                                imageBytes[byteIndex++] = a;
                            } else {
                                // A+R+G+Bé¡ºåº
                                imageBytes[byteIndex++] = a;
                                imageBytes[byteIndex++] = r;
                                imageBytes[byteIndex++] = g;
                                imageBytes[byteIndex++] = b;
                            }
                        } else if (format === 'argb4444') {
                            // ARGB4444æ ¼å¼ï¼š2å­—èŠ‚ï¼ŒA(4bit),R(4bit),G(4bit),B(4bit)
                            const a4 = (a >> 4) & 0x0F;
                            const r4 = (r >> 4) & 0x0F;
                            const g4 = (g >> 4) & 0x0F;
                            const b4 = (b >> 4) & 0x0F;
                            const value = (a4 << 12) | (r4 << 8) | (g4 << 4) | b4;
                            const lowByte = value & 0xFF;
                            const highByte = (value >> 8) & 0xFF;

                            // æ£€æŸ¥åå­—åºè®¾ç½®
                            if (isReverseOrder) {
                                // ä½å­—èŠ‚åœ¨å‰ï¼Œé«˜å­—èŠ‚åœ¨åï¼ˆå°ç«¯åºï¼‰
                                imageBytes[byteIndex++] = lowByte;
                                imageBytes[byteIndex++] = highByte;
                            } else {
                                // é«˜å­—èŠ‚åœ¨å‰ï¼Œä½å­—èŠ‚åœ¨åï¼ˆå¤§ç«¯åºï¼‰
                                imageBytes[byteIndex++] = highByte;
                                imageBytes[byteIndex++] = lowByte;
                            }
                        } else if (format === 'argb2222') {
                            // ARGB2222æ ¼å¼ï¼š1å­—èŠ‚ï¼ŒA(2bit),R(2bit),G(2bit),B(2bit)
                            const a2 = (a >> 6) & 0x03;
                            const r2 = (r >> 6) & 0x03;
                            const g2 = (g >> 6) & 0x03;
                            const b2 = (b >> 6) & 0x03;
                            const value = (a2 << 6) | (r2 << 4) | (g2 << 2) | b2;
                            imageBytes[byteIndex++] = value;
                        }
                }
            }

            // æ£€æŸ¥æ˜¯å¦å¯ç”¨å‹ç¼©
            const useRle = compressionAlgorithmSelect.value === 'rle';
            // åº”ç”¨RLEå‹ç¼©
            let finalBytes;
            if (useRle) {
                finalBytes = rleCompress(imageBytes, format);
            } else {
                // éå‹ç¼©æ¨¡å¼ä¸‹ï¼Œç›´æ¥ä½¿ç”¨TypedArrayæ•°æ®ï¼Œé¿å…å†…å­˜æ‹·è´
                // ä½†éœ€è¦è½¬æ¢ä¸ºæ•°ç»„ä»¥ä¿æŒæ¥å£ä¸€è‡´æ€§
                finalBytes = Array.from(imageBytes);
            }

            // ç”Ÿæˆæ•°ç»„åç§°ï¼Œç¬¬ä¸€å¼ å›¾ç‰‡ç›´æ¥ä½¿ç”¨å‰ç¼€ï¼Œåç»­å›¾ç‰‡æ·»åŠ _1,_2ç­‰
            const arrayPrefix = imgIndex === 0 ? card.arrayPrefix : `${card.arrayPrefix}_${imgIndex}`;

            // ç¡®å®šformatå­—æ®µå€¼
            let formatValue = 'SGL_PIXMAP_FMT_NONE';
            if (useRle) {
                if (format === 'rgb888') {
                    formatValue = 'SGL_PIXMAP_FMT_RLE_RGB888';
                } else if (format === 'rgb565') {
                    formatValue = 'SGL_PIXMAP_FMT_RLE_RGB565';
                } else if (format === 'rgb332') {
                    formatValue = 'SGL_PIXMAP_FMT_RLE_RGB332';
                } else if (format === 'argb8888') {
                    formatValue = 'SGL_PIXMAP_FMT_RLE_ARGB8888';
                } else if (format === 'argb4444') {
                    formatValue = 'SGL_PIXMAP_FMT_RLE_ARGB4444';
                } else if (format === 'argb2222') {
                    formatValue = 'SGL_PIXMAP_FMT_RLE_ARGB2222';
                }
            } else {
                if (format === 'rgb888') {
                    formatValue = 'SGL_PIXMAP_FMT_RGB888';
                } else if (format === 'rgb565') {
                    formatValue = 'SGL_PIXMAP_FMT_RGB565';
                } else if (format === 'rgb332') {
                    formatValue = 'SGL_PIXMAP_FMT_RGB332';
                } else if (format === 'argb8888') {
                    formatValue = 'SGL_PIXMAP_FMT_ARGB8888';
                } else if (format === 'argb4444') {
                    formatValue = 'SGL_PIXMAP_FMT_ARGB4444';
                } else if (format === 'argb2222') {
                    formatValue = 'SGL_PIXMAP_FMT_ARGB2222';
                }
            }

            // è¿”å›å¤„ç†ç»“æœ
            return {
                card: card,
                arrayPrefix: arrayPrefix,
                finalBytes: finalBytes,
                formatValue: formatValue,
                width: card.width,
                height: card.height,
                imgIndex: imgIndex,
                cardIndex: cardIndex
            };
        }

        // æ–‡ä»¶ä¸‹è½½å‡½æ•°
        function downloadFile(filename, content) {
            const a = document.createElement('a');

            if (typeof content === 'string') {
                const blob = new Blob([content], { type: 'text/plain' });
                a.href = URL.createObjectURL(blob);
            } else {
                a.href = URL.createObjectURL(content);
            }

            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
        }

        // å¯¼å‡ºé¢„è§ˆå‡½æ•°
        async function exportPreview() {
            // è·å–å…¨å±€è®¾ç½®
            const colorFormat = document.getElementById('colorFormat').value;
            const outputFormat = document.getElementById('outputFormat').value;
            const filename = document.getElementById('filename');

            // æ£€æŸ¥æ–‡ä»¶åæ˜¯å¦ä¸ºç©º
            if (!filename.value) {
                alert('é”™è¯¯ï¼šæ–‡ä»¶åä¸èƒ½ä¸ºç©ºï¼è¯·è¾“å…¥æœ‰æ•ˆçš„æ–‡ä»¶åã€‚');
                return;
            }

            // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å¡ç‰‡éƒ½é€‰æ‹©äº†å›¾ç‰‡
            for (const card of cards) {
                if (!card.isValid) {
                    alert(`é”™è¯¯ï¼šå›¾ç‰‡ ${card.index + 1} æ²¡æœ‰é€‰æ‹©å›¾ç‰‡ï¼`);
                    return;
                }
            }

            // æ£€æŸ¥æ•°ç»„åå‰ç¼€æ˜¯å¦å”¯ä¸€
            if (!checkArrayPrefixUnique()) {
                alert('é”™è¯¯ï¼šæ•°ç»„åå‰ç¼€å¿…é¡»å”¯ä¸€ï¼è¯·ä¿®æ”¹é‡å¤çš„æ•°ç»„åå‰ç¼€ã€‚');
                return;
            }

            try {
                // æ˜¾ç¤ºè¿›åº¦æ¡
                resetProgress();
                updateProgress(0, 'å‡†å¤‡ç”Ÿæˆé¢„è§ˆ...');

                let content;
                if (outputFormat === '.c') {
                    // ç”ŸæˆCæ–‡ä»¶å†…å®¹ç”¨äºé¢„è§ˆ
                    content = await generateCFileContent(filename.value, colorFormat, (processed, total) => {
                        const progress = Math.min(90, (processed / total) * 90);
                        updateProgress(progress, `æ­£åœ¨å¤„ç†å›¾ç‰‡ ${processed}/${total}...`);
                    });
                } else {
                    // å¯¹äºbinæ ¼å¼ï¼Œç”Ÿæˆå¯¹åº”çš„Cæ–‡ä»¶å†…å®¹ç”¨äºé¢„è§ˆ
                    // æ¨¡æ‹Ÿç”Ÿæˆbinæ–‡ä»¶çš„è¿‡ç¨‹ï¼Œè·å–å›¾ç‰‡ä¿¡æ¯
                    const imageInfo = [];
                    let currentOffset = 0;

                    // æ”¶é›†æ‰€æœ‰éœ€è¦å¤„ç†çš„å›¾ç‰‡ä»»åŠ¡
                    const imageTasks = [];
                    const totalImages = cards.reduce((sum, card) => sum + card.images.length, 0);
                    let processedImages = 0;

                    // æ”¶é›†ä»»åŠ¡
                    for (let cardIndex = 0; cardIndex < cards.length; cardIndex++) {
                        const card = cards[cardIndex];

                        // æ·»åŠ å½“å‰å¡ç‰‡çš„æ‰€æœ‰å›¾ç‰‡å¤„ç†ä»»åŠ¡
                        for (let imgIndex = 0; imgIndex < card.images.length; imgIndex++) {
                            const imageItem = card.images[imgIndex];
                            // åˆ›å»ºå›¾ç‰‡å¤„ç†ä»»åŠ¡
                            imageTasks.push(async () => {
                                const result = await processImageForBin(card, imageItem, imgIndex, cardIndex, colorFormat);
                                // è°ƒç”¨è¿›åº¦å›è°ƒ
                                processedImages++;
                                updateProgress(Math.min(90, (processedImages / totalImages) * 90), `æ­£åœ¨å¤„ç†å›¾ç‰‡ ${processedImages}/${totalImages}...`);
                                return result;
                            });
                        }
                    }

                    // æ‰§è¡Œå¹¶å‘ä»»åŠ¡
                    const optimalConcurrency = getOptimalConcurrency();
                    const results = await concurrencyControl(imageTasks, optimalConcurrency);

                    // å¤„ç†ç»“æœï¼ŒæŒ‰é¡ºåºç”Ÿæˆå†…å®¹
                    results.sort((a, b) => {
                        if (a.cardIndex !== b.cardIndex) {
                            return a.cardIndex - b.cardIndex;
                        }
                        return a.imgIndex - b.imgIndex;
                    });

                    // è®¡ç®—åç§»é‡å¹¶ç”Ÿæˆå›¾ç‰‡ä¿¡æ¯
                    for (const result of results) {
                        const startAddress = currentOffset;
                        currentOffset += result.finalBytes.length;

                        imageInfo.push({
                            card: result.card,
                            name: result.arrayPrefix,
                            startAddress: startAddress,
                            dataSize: result.finalBytes.length,
                            format: result.formatValue,
                            width: result.width,
                            height: result.height
                        });
                    }

                    // ç”Ÿæˆå¯¹åº”çš„Cæ–‡ä»¶å†…å®¹
                    const contentArray = [];
                    contentArray.push(`#include <stdint.h>\n`);
                    contentArray.push(`#include <sgl_core.h>\n\n`);
                    contentArray.push(`// ${filename.value} - Generated by Image To Array Tool\n\n`);
                    contentArray.push(`// å›¾ç‰‡æ•°æ®ç»“æ„ä½“å®šä¹‰\n`);

                    // æŒ‰å¡ç‰‡åˆ†ç»„å›¾ç‰‡ä¿¡æ¯
                    const cardGroups = {};
                    imageInfo.forEach(info => {
                        if (!cardGroups[info.card.arrayPrefix]) {
                            cardGroups[info.card.arrayPrefix] = [];
                        }
                        cardGroups[info.card.arrayPrefix].push(info);
                    });

                    // éå†æ¯ä¸ªå¡ç‰‡ç»„
                    for (const [prefix, infos] of Object.entries(cardGroups)) {
                        const card = infos[0].card;
                        const cardElement = document.querySelector(`[data-card-index="${card.index}"]`);
                        // è·å–â€œç»„åˆä¸ºæ•°ç»„â€å•é€‰æ¡†çŠ¶æ€ï¼Œé»˜è®¤é€‰ä¸­
                        const combineAsArray = cardElement.querySelector('.combine-as-array')?.checked ?? true;

                        if (combineAsArray && infos.length > 1) {
                            // ç»„åˆä¸ºæ•°ç»„
                            contentArray.push(`// ${prefix} ç»“æ„ä½“æ•°ç»„ - ${infos.length}å¼ å›¾ç‰‡\n`);
                            contentArray.push(`const sgl_pixmap_t ${prefix}_array[${infos.length}] = {\n`);

                            for (let i = 0; i < infos.length; i++) {
                                const info = infos[i];
                                contentArray.push(`    {\n`);
                                contentArray.push(`        .width = ${info.width},\n`);
                                contentArray.push(`        .height = ${info.height},\n`);
                                contentArray.push(`        .bitmap.addr = 0x${info.startAddress.toString(16).padStart(8, '0')}, // å›¾ç‰‡åœ¨BINæ–‡ä»¶ä¸­çš„èµ·å§‹åœ°å€\n`);
                                contentArray.push(`        .format = ${info.format}\n`);
                                contentArray.push(`    }${i < infos.length - 1 ? ',' : ''}\n`);
                            }

                            contentArray.push(`};\n\n`);
                        } else {
                            // å•ç‹¬è¾“å‡º
                            for (const info of infos) {
                                contentArray.push(`// ${info.name} - ${info.width}x${info.height} ${colorFormat.toUpperCase()}${info.format.includes('RLE') ? ' (RLEå‹ç¼©)' : ''}\n`);
                                contentArray.push(`const sgl_pixmap_t ${info.name}_pixmap = {\n`);
                                contentArray.push(`    .width = ${info.width},\n`);
                                contentArray.push(`    .height = ${info.height},\n`);
                                contentArray.push(`    .bitmap.addr = 0x${info.startAddress.toString(16).padStart(8, '0')}, // å›¾ç‰‡åœ¨BINæ–‡ä»¶ä¸­çš„èµ·å§‹åœ°å€\n`);
                                contentArray.push(`    .format = ${info.format},\n`);
                                contentArray.push(`};\n\n`);
                            }
                        }
                    }

                    content = contentArray.join('');
                }

                // å®Œæˆè¿›åº¦æ¡
                updateProgress(100, 'é¢„è§ˆç”Ÿæˆå®Œæˆï¼');

                // æ˜¾ç¤ºé¢„è§ˆå¼¹çª—
                showPreviewModal(content, filename.value);
            } catch (error) {
                // é‡ç½®è¿›åº¦æ¡
                resetProgress();
                alert('é¢„è§ˆå¤±è´¥ï¼š' + error.message);
            }
        }

        // ç”ŸæˆCæ–‡ä»¶å†…å®¹ï¼ˆç”¨äºé¢„è§ˆï¼‰
        async function generateCFileContent(filename, format, progressCallback) {
            // ç›´æ¥è°ƒç”¨å…¬å…±å‡½æ•°ç”ŸæˆCæ–‡ä»¶å†…å®¹
            return await generateCFileContentCommon(filename, format, progressCallback);
        }

        // æ˜¾ç¤ºé¢„è§ˆå¼¹çª—
        function showPreviewModal(content, filename) {
            const modal = document.getElementById('previewModal');
            const codePreview = document.getElementById('codePreview');
            const previewTabs = document.getElementById('previewTabs');
            const closeModalButton = document.getElementById('closeModalButton');
            const copyButton = document.getElementById('copyButton');

            // è®¾ç½®é¢„è§ˆå†…å®¹
            codePreview.textContent = content;

            // æ¸…ç©ºæ ‡ç­¾é¡µ
            previewTabs.innerHTML = '';

            // æ·»åŠ æ ‡ç­¾é¡µï¼ˆä½¿ç”¨æ–‡ä»¶åä½œä¸ºæ ‡ç­¾ï¼‰
            const tabButton = document.createElement('button');
            tabButton.textContent = `${filename}.c`;
            tabButton.style.padding = '12px 24px';
            tabButton.style.border = 'none';
            tabButton.style.background = '#4facfe';
            tabButton.style.color = 'white';
            tabButton.style.fontSize = '1em';
            tabButton.style.fontWeight = '500';
            tabButton.style.cursor = 'pointer';
            tabButton.style.borderBottom = '3px solid #4facfe';
            tabButton.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.1)';
            previewTabs.appendChild(tabButton);

            // è®¡ç®—å¼¹çª—å¤§å°
            const containerWidth = document.querySelector('.container').clientWidth;
            const modalWidth = containerWidth * 0.8;
            const modalHeight = modalWidth * 0.8;

            // è®¾ç½®å¼¹çª—å¤§å°
            const modalContent = document.getElementById('previewModalContent');
            modalContent.style.width = `${modalWidth}px`;
            modalContent.style.height = `${modalHeight}px`;

            // æ˜¾ç¤ºå¼¹çª—
            modal.style.display = 'flex';

            // å…³é—­æŒ‰é’®äº‹ä»¶
            closeModalButton.onclick = function() {
                modal.style.display = 'none';
            };

            // å¤åˆ¶æŒ‰é’®äº‹ä»¶
            copyButton.onclick = function() {
                navigator.clipboard.writeText(content).then(function() {
                    // æ˜¾ç¤ºå¤åˆ¶æˆåŠŸæç¤º
                    const originalText = copyButton.textContent;
                    copyButton.textContent = 'å¤åˆ¶æˆåŠŸï¼';
                    copyButton.style.background = 'rgba(76, 175, 80, 0.9)';
                    copyButton.style.color = 'white';

                    // æ¢å¤æŒ‰é’®çŠ¶æ€
                    setTimeout(function() {
                        copyButton.textContent = originalText;
                        copyButton.style.background = 'rgba(255, 255, 255, 0.9)';
                        copyButton.style.color = '#4facfe';
                    }, 2000);
                }).catch(function(err) {
                    alert('å¤åˆ¶å¤±è´¥ï¼š', err);
                });
            };

            // ç‚¹å‡»å¼¹çª—å¤–éƒ¨å…³é—­
            window.onclick = function(event) {
                if (event.target == modal) {
                    modal.style.display = 'none';
                }
            };
        }
    </script>
</body>
</html>
